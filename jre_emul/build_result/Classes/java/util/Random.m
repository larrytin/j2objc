//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//
//  Created by Larry Tin <dev@goodow.com>
//

#include "IOSByteArray.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/System.h"
#include "java/util/Random.h"
#import <math.h>

@implementation JavaUtilRandom

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)init {
  if (self = [super init]) {
    [self setSeedWithLong:[JavaLangSystem currentTimeMillis] + [self hash]];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithLong:(long long int)seed {
  if (self = [super init]) {
    [self setSeedWithLong:seed];
    JreMemDebugAdd(self);
  }
  return self;
}

- (int)nextWithInt:(int)bits {
  @synchronized(self) {
    {
      seed_ = (seed_ * JavaUtilRandom_multiplier + (long long) 0xbLL) & ((1LL << 48) - 1);
      return (int) ((long long) (((unsigned long long) seed_) >> (48 - bits)));
    }
  }
}

- (BOOL)nextBoolean {
  return [self nextWithInt:1] != 0;
}

- (void)nextBytesWithByteArray:(IOSByteArray *)buf {
  int rand = 0, count = 0, loop = 0;
  while (count < (int) [((IOSByteArray *) nil_chk(buf)) count]) {
    if (loop == 0) {
      rand = [self nextInt];
      loop = 3;
    }
    else {
      loop--;
    }
    (*IOSByteArray_GetRef(buf, count++)) = (char) rand;
    rand >>= 8;
  }
}

- (double)nextDouble {
  return ((((long long int) [self nextWithInt:26] << 27) + [self nextWithInt:27]) / (double) (1LL << 53));
}

- (float)nextFloat {
  return ([self nextWithInt:24] / 16777216.0f);
}

- (double)nextGaussian {
  @synchronized(self) {
    {
      if (haveNextNextGaussian_) {
        haveNextNextGaussian_ = NO;
        return nextNextGaussian_;
      }
      double v1, v2, s;
      do {
        v1 = 2 * [self nextDouble] - 1;
        v2 = 2 * [self nextDouble] - 1;
        s = v1 * v1 + v2 * v2;
      }
      while (s >= 1);
      double norm = [JavaUtilRandom iOS_sqrtWithDouble:-2 * [JavaUtilRandom iOS_logWithDouble:s] / s];
      nextNextGaussian_ = v2 * norm;
      haveNextNextGaussian_ = YES;
      return v1 * norm;
    }
  }
}

+ (double)iOS_sqrtWithDouble:(double)a {
  // Use math.h function.
  return sqrt(a);
}

+ (double)iOS_logWithDouble:(double)a {
  // Use math.h function.
  return log(a);
}

- (int)nextInt {
  return [self nextWithInt:32];
}

- (int)nextIntWithInt:(int)n {
  if (n > 0) {
    if ((n & -n) == n) {
      return (int) ((n * (long long int) [self nextWithInt:31]) >> 31);
    }
    int bits, val;
    do {
      bits = [self nextWithInt:31];
      val = bits % n;
    }
    while (bits - val + (n - 1) < 0);
    return val;
  }
  @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
}

- (long long int)nextLong {
  return ((long long int) [self nextWithInt:32] << 32) + [self nextWithInt:32];
}

- (void)setSeedWithLong:(long long int)seed {
  @synchronized(self) {
    {
      self->seed_ = (seed ^ JavaUtilRandom_multiplier) & ((1LL << 48) - 1);
      haveNextNextGaussian_ = NO;
    }
  }
}

- (void)copyAllFieldsTo:(JavaUtilRandom *)other {
  [super copyAllFieldsTo:other];
  other->haveNextNextGaussian_ = haveNextNextGaussian_;
  other->nextNextGaussian_ = nextNextGaussian_;
  other->seed_ = seed_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  return result;
}

@end
