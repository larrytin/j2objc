//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//
//  Created by Larry Tin <dev@goodow.com>
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "java/lang/CloneNotSupportedException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/util/Arrays.h"
#include "java/util/Collection.h"
#include "java/util/Collections.h"
#include "java/util/ConcurrentModificationException.h"
#include "java/util/Enumeration.h"
#include "java/util/Hashtable.h"
#include "java/util/Iterator.h"
#include "java/util/Map.h"
#include "java/util/MapEntry.h"
#include "java/util/NoSuchElementException.h"
#include "java/util/Set.h"

@implementation JavaUtilHashtable

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaUtilHashtable_EMPTY_ENUMERATION_ name:@"JavaUtilHashtable_EMPTY_ENUMERATION_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaUtilHashtable_EMPTY_ITERATOR_ name:@"JavaUtilHashtable_EMPTY_ITERATOR_"]];
  return result;
}

static id<JavaUtilEnumeration> JavaUtilHashtable_EMPTY_ENUMERATION_;
static id<JavaUtilIterator> JavaUtilHashtable_EMPTY_ITERATOR_;

+ (id<JavaUtilEnumeration>)EMPTY_ENUMERATION {
  return JavaUtilHashtable_EMPTY_ENUMERATION_;
}

+ (id<JavaUtilIterator>)EMPTY_ITERATOR {
  return JavaUtilHashtable_EMPTY_ITERATOR_;
}

+ (JavaUtilHashtable_Entry *)newEntryWithId:(id)key
                                     withId:(id)value
                                    withInt:(int)hash_ {
  return [[[JavaUtilHashtable_Entry alloc] initWithId:key withId:value] autorelease];
}

- (id)init {
  return JreMemDebugAdd([self initJavaUtilHashtableWithInt:11]);
}

- (id)initJavaUtilHashtableWithInt:(int)capacity {
  if (self = [super init]) {
    lastSlot_ = -1;
    if (capacity >= 0) {
      elementCount_ = 0;
      JavaUtilHashtable_set_elementData_(self, [self newElementArrayWithInt:capacity == 0 ? 1 : capacity]);
      firstSlot_ = (int) [((IOSObjectArray *) nil_chk(elementData_)) count];
      loadFactor_ = 0.75f;
      [self computeMaxSize];
    }
    else {
      @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithInt:(int)capacity {
  return [self initJavaUtilHashtableWithInt:capacity];
}

- (id)initWithInt:(int)capacity
        withFloat:(float)loadFactor {
  if (self = [super init]) {
    lastSlot_ = -1;
    if (capacity >= 0 && loadFactor > 0) {
      elementCount_ = 0;
      firstSlot_ = capacity;
      JavaUtilHashtable_set_elementData_(self, [self newElementArrayWithInt:capacity == 0 ? 1 : capacity]);
      self->loadFactor_ = loadFactor;
      [self computeMaxSize];
    }
    else {
      @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaUtilMap:(id<JavaUtilMap>)map {
  if (self = [self initJavaUtilHashtableWithInt:[((id<JavaUtilMap>) nil_chk(map)) size] < 6 ? 11 : ([map size] * 4 / 3) + 11]) {
    [self putAllWithJavaUtilMap:map];
    JreMemDebugAdd(self);
  }
  return self;
}

- (IOSObjectArray *)newElementArrayWithInt:(int)size {
  return [IOSObjectArray arrayWithLength:size type:[IOSClass classWithClass:[JavaUtilHashtable_Entry class]]];
}

- (void)clear {
  @synchronized(self) {
    {
      elementCount_ = 0;
      [JavaUtilArrays fillWithNSObjectArray:elementData_ withId:nil];
      modCount_++;
    }
  }
}

- (id)clone {
  @synchronized(self) {
    {
      @try {
        JavaUtilHashtable *hashtable = (JavaUtilHashtable *) check_class_cast([super clone], [JavaUtilHashtable class]);
        JavaUtilHashtable_set_elementData_(nil_chk(hashtable), [IOSObjectArray arrayWithLength:(int) [((IOSObjectArray *) nil_chk(elementData_)) count] type:[IOSClass classWithClass:[JavaUtilHashtable_Entry class]]]);
        JavaUtilHashtable_Entry *entry;
        for (int i = (int) [elementData_ count]; --i >= 0; ) {
          if ((entry = IOSObjectArray_Get(elementData_, i)) != nil) {
            IOSObjectArray_Set(hashtable->elementData_, i, (JavaUtilHashtable_Entry *) check_class_cast([((JavaUtilHashtable_Entry *) nil_chk(entry)) clone], [JavaUtilHashtable_Entry class]));
          }
        }
        return hashtable;
      }
      @catch (JavaLangCloneNotSupportedException *e) {
        return nil;
      }
    }
  }
}

- (void)computeMaxSize {
  threshold_ = (int) ((int) [((IOSObjectArray *) nil_chk(elementData_)) count] * loadFactor_);
}

- (BOOL)containsWithId:(id)value {
  @synchronized(self) {
    {
      if (value == nil) {
        @throw [[[JavaLangNullPointerException alloc] init] autorelease];
      }
      for (int i = (int) [((IOSObjectArray *) nil_chk(elementData_)) count]; --i >= 0; ) {
        JavaUtilHashtable_Entry *entry = IOSObjectArray_Get(elementData_, i);
        while (entry != nil) {
          if ([nil_chk(((JavaUtilHashtable_Entry *) nil_chk(entry))->value_) isEqual:value]) {
            return YES;
          }
          entry = entry->next_;
        }
      }
      return NO;
    }
  }
}

- (BOOL)containsKeyWithId:(id)key {
  @synchronized(self) {
    {
      return [self getEntryWithId:key] != nil;
    }
  }
}

- (BOOL)containsValueWithId:(id)value {
  return [self containsWithId:value];
}

- (id<JavaUtilEnumeration>)elements {
  @synchronized(self) {
    {
      if (elementCount_ == 0) {
        return (id<JavaUtilEnumeration>) check_protocol_cast(JavaUtilHashtable_EMPTY_ENUMERATION_, @protocol(JavaUtilEnumeration));
      }
      return [[[JavaUtilHashtable_HashEnumIterator alloc] initWithJavaUtilHashtable:self withJavaUtilMapEntry_Type:[[[JavaUtilHashtable_$3 alloc] init] autorelease] withBoolean:YES] autorelease];
    }
  }
}

- (id<JavaUtilSet>)entrySet {
  return [[[JavaUtilCollections_SynchronizedSet alloc] initWithJavaUtilSet:[[[JavaUtilHashtable_$4 alloc] initWithJavaUtilHashtable:self] autorelease] withId:self] autorelease];
}

- (BOOL)isEqual:(id)object {
  @synchronized(self) {
    {
      if (self == object) {
        return YES;
      }
      if ([object conformsToProtocol: @protocol(JavaUtilMap)]) {
        id<JavaUtilMap> map = (id<JavaUtilMap>) check_protocol_cast(object, @protocol(JavaUtilMap));
        if ([self size] != [((id<JavaUtilMap>) nil_chk(map)) size]) {
          return NO;
        }
        id<JavaUtilSet> entries = [self entrySet];
        for (id<JavaUtilMap_Entry> __strong e in [map entrySet]) {
          if (![((id<JavaUtilSet>) nil_chk(entries)) containsWithId:e]) {
            return NO;
          }
        }
        return YES;
      }
      return NO;
    }
  }
}

- (id)getWithId:(id)key {
  @synchronized(self) {
    {
      int hash_ = [nil_chk(key) hash];
      int index = (hash_ & (int) 0x7FFFFFFF) % (int) [((IOSObjectArray *) nil_chk(elementData_)) count];
      JavaUtilHashtable_Entry *entry = IOSObjectArray_Get(elementData_, index);
      while (entry != nil) {
        if ([((JavaUtilHashtable_Entry *) nil_chk(entry)) equalsKeyWithId:key withInt:hash_]) {
          return entry->value_;
        }
        entry = entry->next_;
      }
      return nil;
    }
  }
}

- (JavaUtilHashtable_Entry *)getEntryWithId:(id)key {
  int hash_ = [nil_chk(key) hash];
  int index = (hash_ & (int) 0x7FFFFFFF) % (int) [((IOSObjectArray *) nil_chk(elementData_)) count];
  JavaUtilHashtable_Entry *entry = IOSObjectArray_Get(elementData_, index);
  while (entry != nil) {
    if ([((JavaUtilHashtable_Entry *) nil_chk(entry)) equalsKeyWithId:key withInt:hash_]) {
      return entry;
    }
    entry = entry->next_;
  }
  return nil;
}

- (NSUInteger)hash {
  @synchronized(self) {
    {
      int result = 0;
      id<JavaUtilIterator> it = [((id<JavaUtilSet>) nil_chk([self entrySet])) iterator];
      while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
        id<JavaUtilMap_Entry> entry = [it next];
        id key = [((id<JavaUtilMap_Entry>) nil_chk(entry)) getKey];
        if (key == self) {
          continue;
        }
        id value = [entry getValue];
        if (value == self) {
          continue;
        }
        int hash_ = (key != nil ? [key hash] : 0) ^ (value != nil ? [value hash] : 0);
        result += hash_;
      }
      return result;
    }
  }
}

- (BOOL)isEmpty {
  @synchronized(self) {
    {
      return elementCount_ == 0;
    }
  }
}

- (id<JavaUtilEnumeration>)keys {
  @synchronized(self) {
    {
      if (elementCount_ == 0) {
        return (id<JavaUtilEnumeration>) check_protocol_cast(JavaUtilHashtable_EMPTY_ENUMERATION_, @protocol(JavaUtilEnumeration));
      }
      return [[[JavaUtilHashtable_HashEnumIterator alloc] initWithJavaUtilHashtable:self withJavaUtilMapEntry_Type:[[[JavaUtilHashtable_$5 alloc] init] autorelease] withBoolean:YES] autorelease];
    }
  }
}

- (id<JavaUtilSet>)keySet {
  return [[[JavaUtilCollections_SynchronizedSet alloc] initWithJavaUtilSet:[[[JavaUtilHashtable_$6 alloc] initWithJavaUtilHashtable:self] autorelease] withId:self] autorelease];
}

- (id)putWithId:(id)key
         withId:(id)value {
  @synchronized(self) {
    {
      if (key != nil && value != nil) {
        int hash_ = [key hash];
        int index = (hash_ & (int) 0x7FFFFFFF) % (int) [((IOSObjectArray *) nil_chk(elementData_)) count];
        JavaUtilHashtable_Entry *entry = IOSObjectArray_Get(elementData_, index);
        while (entry != nil && ![entry equalsKeyWithId:key withInt:hash_]) {
          entry = ((JavaUtilHashtable_Entry *) nil_chk(entry))->next_;
        }
        if (entry == nil) {
          modCount_++;
          if (++elementCount_ > threshold_) {
            [self rehash];
            index = (hash_ & (int) 0x7FFFFFFF) % (int) [elementData_ count];
          }
          if (index < firstSlot_) {
            firstSlot_ = index;
          }
          if (index > lastSlot_) {
            lastSlot_ = index;
          }
          entry = [JavaUtilHashtable newEntryWithId:key withId:value withInt:hash_];
          JavaUtilHashtable_Entry_set_next_(nil_chk(entry), IOSObjectArray_Get(elementData_, index));
          IOSObjectArray_Set(elementData_, index, entry);
          return nil;
        }
        id result = ((JavaUtilHashtable_Entry *) nil_chk(entry))->value_;
        JavaUtilMapEntry_set_value_(entry, value);
        return result;
      }
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
  }
}

- (void)putAllWithJavaUtilMap:(id<JavaUtilMap>)map {
  @synchronized(self) {
    {
      for (id<JavaUtilMap_Entry> __strong entry in [((id<JavaUtilMap>) nil_chk(map)) entrySet]) {
        [self putWithId:[((id<JavaUtilMap_Entry>) nil_chk(entry)) getKey] withId:[entry getValue]];
      }
    }
  }
}

- (void)rehash {
  int length = ((int) [((IOSObjectArray *) nil_chk(elementData_)) count] << 1) + 1;
  if (length == 0) {
    length = 1;
  }
  int newFirst = length;
  int newLast = -1;
  IOSObjectArray *newData = [self newElementArrayWithInt:length];
  for (int i = lastSlot_ + 1; --i >= firstSlot_; ) {
    JavaUtilHashtable_Entry *entry = IOSObjectArray_Get(elementData_, i);
    while (entry != nil) {
      int index = ([((JavaUtilHashtable_Entry *) nil_chk(entry)) getKeyHash] & (int) 0x7FFFFFFF) % length;
      if (index < newFirst) {
        newFirst = index;
      }
      if (index > newLast) {
        newLast = index;
      }
      JavaUtilHashtable_Entry *next = entry->next_;
      JavaUtilHashtable_Entry_set_next_(entry, IOSObjectArray_Get(nil_chk(newData), index));
      IOSObjectArray_Set(newData, index, entry);
      entry = next;
    }
  }
  firstSlot_ = newFirst;
  lastSlot_ = newLast;
  JavaUtilHashtable_set_elementData_(self, newData);
  [self computeMaxSize];
}

- (id)removeWithId:(id)key {
  @synchronized(self) {
    {
      int hash_ = [nil_chk(key) hash];
      int index = (hash_ & (int) 0x7FFFFFFF) % (int) [((IOSObjectArray *) nil_chk(elementData_)) count];
      JavaUtilHashtable_Entry *last = nil;
      JavaUtilHashtable_Entry *entry = IOSObjectArray_Get(elementData_, index);
      while (entry != nil && ![entry equalsKeyWithId:key withInt:hash_]) {
        last = entry;
        entry = ((JavaUtilHashtable_Entry *) nil_chk(entry))->next_;
      }
      if (entry != nil) {
        modCount_++;
        if (last == nil) {
          IOSObjectArray_Set(elementData_, index, entry->next_);
        }
        else {
          JavaUtilHashtable_Entry_set_next_(last, entry->next_);
        }
        elementCount_--;
        id result = entry->value_;
        JavaUtilMapEntry_set_value_(entry, nil);
        return result;
      }
      return nil;
    }
  }
}

- (int)size {
  @synchronized(self) {
    {
      return elementCount_;
    }
  }
}

- (NSString *)description {
  @synchronized(self) {
    {
      if ([self isEmpty]) {
        return @"{}";
      }
      JavaLangStringBuilder *buffer = [[[JavaLangStringBuilder alloc] initWithInt:[self size] * 28] autorelease];
      [buffer appendWithChar:'{'];
      for (int i = lastSlot_; i >= firstSlot_; i--) {
        JavaUtilHashtable_Entry *entry = IOSObjectArray_Get(nil_chk(elementData_), i);
        while (entry != nil) {
          if (((JavaUtilHashtable_Entry *) nil_chk(entry))->key_ != self) {
            [buffer appendWithId:entry->key_];
          }
          else {
            [buffer appendWithNSString:@"(this Map)"];
          }
          [buffer appendWithChar:'='];
          if (entry->value_ != self) {
            [buffer appendWithId:entry->value_];
          }
          else {
            [buffer appendWithNSString:@"(this Map)"];
          }
          [buffer appendWithNSString:@", "];
          entry = entry->next_;
        }
      }
      if (elementCount_ > 0) {
        [buffer setLengthWithInt:[buffer sequenceLength] - 2];
      }
      [buffer appendWithChar:'}'];
      return [buffer description];
    }
  }
}

- (id<JavaUtilCollection>)values {
  return [[[JavaUtilCollections_SynchronizedCollection alloc] initWithJavaUtilCollection:[[[JavaUtilHashtable_$7 alloc] initWithJavaUtilHashtable:self] autorelease] withId:self] autorelease];
}

+ (void)initialize {
  if (self == [JavaUtilHashtable class]) {
    JreOperatorRetainedAssign(&JavaUtilHashtable_EMPTY_ENUMERATION_, nil, [[[JavaUtilHashtable_$1 alloc] init] autorelease]);
    JreOperatorRetainedAssign(&JavaUtilHashtable_EMPTY_ITERATOR_, nil, [[[JavaUtilHashtable_$2 alloc] init] autorelease]);
  }
}

- (id)copyWithZone:(NSZone *)zone {
  return [[self clone] retain];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilHashtable_set_elementData_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaUtilHashtable *)other {
  [super copyAllFieldsTo:other];
  other->elementCount_ = elementCount_;
  JavaUtilHashtable_set_elementData_(other, elementData_);
  other->firstSlot_ = firstSlot_;
  other->lastSlot_ = lastSlot_;
  other->loadFactor_ = loadFactor_;
  other->modCount_ = modCount_;
  other->threshold_ = threshold_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:elementData_ name:@"elementData"]];
  return result;
}

@end
@implementation JavaUtilHashtable_Entry

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithId:(id)theKey
          withId:(id)theValue {
  if (self = [super initWithId:theKey withId:theValue]) {
    hashcode_ = [nil_chk(theKey) hash];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)clone {
  JavaUtilHashtable_Entry *entry = (JavaUtilHashtable_Entry *) check_class_cast([super clone], [JavaUtilHashtable_Entry class]);
  if (next_ != nil) {
    JavaUtilHashtable_Entry_set_next_(nil_chk(entry), (JavaUtilHashtable_Entry *) check_class_cast([next_ clone], [JavaUtilHashtable_Entry class]));
  }
  return entry;
}

- (id)setValueWithId:(id)object {
  if (object == nil) {
    @throw [[[JavaLangNullPointerException alloc] init] autorelease];
  }
  id result = value_;
  JavaUtilMapEntry_set_value_(self, object);
  return result;
}

- (int)getKeyHash {
  return [nil_chk(key_) hash];
}

- (BOOL)equalsKeyWithId:(id)aKey
                withInt:(int)hash_ {
  return hashcode_ == hash_ && [nil_chk(key_) isEqual:aKey];
}

- (NSString *)description {
  return [NSString stringWithFormat:@"%@=%@", key_, value_];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilHashtable_Entry_set_next_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaUtilHashtable_Entry *)other {
  [super copyAllFieldsTo:other];
  other->hashcode_ = hashcode_;
  JavaUtilHashtable_Entry_set_next_(other, next_);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:next_ name:@"next"]];
  return result;
}

@end
@implementation JavaUtilHashtable_HashIterator

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithJavaUtilHashtable:(JavaUtilHashtable *)outer$
      withJavaUtilMapEntry_Type:(id<JavaUtilMapEntry_Type>)value {
  JavaUtilHashtable_HashIterator_set_this$0_(self, outer$);
  if (self = [super init]) {
    canRemove_ = NO;
    JavaUtilHashtable_HashIterator_set_type_(self, value);
    position_ = outer$->lastSlot_;
    expectedModCount_ = outer$->modCount_;
    JreMemDebugAdd(self);
  }
  return self;
}

- (BOOL)hasNext {
  if (lastEntry_ != nil && lastEntry_->next_ != nil) {
    return YES;
  }
  while (position_ >= this$0_->firstSlot_) {
    if (IOSObjectArray_Get(nil_chk(this$0_->elementData_), position_) == nil) {
      position_--;
    }
    else {
      return YES;
    }
  }
  return NO;
}

- (id)next {
  if (expectedModCount_ == this$0_->modCount_) {
    if (lastEntry_ != nil) {
      JavaUtilHashtable_HashIterator_set_lastEntry_(self, lastEntry_->next_);
    }
    if (lastEntry_ == nil) {
      while (position_ >= this$0_->firstSlot_ && (JavaUtilHashtable_HashIterator_set_lastEntry_(self, IOSObjectArray_Get(nil_chk(this$0_->elementData_), position_))) == nil) {
        position_--;
      }
      if (lastEntry_ != nil) {
        lastPosition_ = position_;
        position_--;
      }
    }
    if (lastEntry_ != nil) {
      canRemove_ = YES;
      return [((id<JavaUtilMapEntry_Type>) nil_chk(type_)) getWithJavaUtilMapEntry:lastEntry_];
    }
    @throw [[[JavaUtilNoSuchElementException alloc] init] autorelease];
  }
  @throw [[[JavaUtilConcurrentModificationException alloc] init] autorelease];
}

- (void)remove {
  if (expectedModCount_ == this$0_->modCount_) {
    if (canRemove_) {
      canRemove_ = NO;
      @synchronized (this$0_) {
        BOOL removed = NO;
        JavaUtilHashtable_Entry *entry = IOSObjectArray_Get(nil_chk(this$0_->elementData_), lastPosition_);
        if (entry == lastEntry_) {
          IOSObjectArray_Set(this$0_->elementData_, lastPosition_, ((JavaUtilHashtable_Entry *) nil_chk(entry))->next_);
          removed = YES;
        }
        else {
          while (entry != nil && entry->next_ != lastEntry_) {
            entry = ((JavaUtilHashtable_Entry *) nil_chk(entry))->next_;
          }
          if (entry != nil) {
            JavaUtilHashtable_Entry_set_next_(entry, ((JavaUtilHashtable_Entry *) nil_chk(lastEntry_))->next_);
            removed = YES;
          }
        }
        if (removed) {
          this$0_->modCount_++;
          this$0_->elementCount_--;
          expectedModCount_++;
          return;
        }
      }
    }
    else {
      @throw [[[JavaLangIllegalStateException alloc] init] autorelease];
    }
  }
  @throw [[[JavaUtilConcurrentModificationException alloc] init] autorelease];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilHashtable_HashIterator_set_lastEntry_(self, nil);
  JavaUtilHashtable_HashIterator_set_type_(self, nil);
  JavaUtilHashtable_HashIterator_set_this$0_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaUtilHashtable_HashIterator *)other {
  [super copyAllFieldsTo:other];
  other->canRemove_ = canRemove_;
  other->expectedModCount_ = expectedModCount_;
  JavaUtilHashtable_HashIterator_set_lastEntry_(other, lastEntry_);
  other->lastPosition_ = lastPosition_;
  other->position_ = position_;
  JavaUtilHashtable_HashIterator_set_type_(other, type_);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:this$0_ name:@"this$0"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:type_ name:@"type"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:lastEntry_ name:@"lastEntry"]];
  return result;
}

@end
@implementation JavaUtilHashtable_HashEnumIterator

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithJavaUtilHashtable:(JavaUtilHashtable *)outer$
      withJavaUtilMapEntry_Type:(id<JavaUtilMapEntry_Type>)value {
  JavaUtilHashtable_HashEnumIterator_set_this$1_(self, outer$);
  if (self = [super initWithJavaUtilHashtable:outer$ withJavaUtilMapEntry_Type:value]) {
    isEnumeration_ = NO;
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaUtilHashtable:(JavaUtilHashtable *)outer$
      withJavaUtilMapEntry_Type:(id<JavaUtilMapEntry_Type>)value
                    withBoolean:(BOOL)isEnumeration {
  JavaUtilHashtable_HashEnumIterator_set_this$1_(self, outer$);
  if (self = [super initWithJavaUtilHashtable:outer$ withJavaUtilMapEntry_Type:value]) {
    isEnumeration_ = NO;
    self->isEnumeration_ = isEnumeration;
    start_ = outer$->lastSlot_ + 1;
    JreMemDebugAdd(self);
  }
  return self;
}

- (BOOL)hasMoreElements {
  if (isEnumeration_) {
    if (entry_ != nil) {
      return YES;
    }
    while (start_ > this$1_->firstSlot_) {
      if (IOSObjectArray_Get(nil_chk(this$1_->elementData_), --start_) != nil) {
        JavaUtilHashtable_HashEnumIterator_set_entry_(self, IOSObjectArray_Get(this$1_->elementData_, start_));
        return YES;
      }
    }
    return NO;
  }
  return [super hasNext];
}

- (BOOL)hasNext {
  if (isEnumeration_) {
    return [self hasMoreElements];
  }
  return [super hasNext];
}

- (id)next {
  if (isEnumeration_) {
    if (expectedModCount_ == this$1_->modCount_) {
      return [self nextElement];
    }
    else {
      @throw [[[JavaUtilConcurrentModificationException alloc] init] autorelease];
    }
  }
  return [super next];
}

- (id)nextElement {
  if (isEnumeration_) {
    if ([self hasMoreElements]) {
      id result = [((id<JavaUtilMapEntry_Type>) nil_chk(type_)) getWithJavaUtilMapEntry:entry_];
      JavaUtilHashtable_HashEnumIterator_set_entry_(self, ((JavaUtilHashtable_Entry *) nil_chk(entry_))->next_);
      return (id) result;
    }
    @throw [[[JavaUtilNoSuchElementException alloc] init] autorelease];
  }
  return [super next];
}

- (void)remove {
  if (isEnumeration_) {
    @throw [[[JavaLangUnsupportedOperationException alloc] init] autorelease];
  }
  else {
    [super remove];
  }
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilHashtable_HashEnumIterator_set_entry_(self, nil);
  JavaUtilHashtable_HashEnumIterator_set_this$1_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaUtilHashtable_HashEnumIterator *)other {
  [super copyAllFieldsTo:other];
  JavaUtilHashtable_HashEnumIterator_set_entry_(other, entry_);
  other->isEnumeration_ = isEnumeration_;
  other->start_ = start_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:this$1_ name:@"this$1"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:entry_ name:@"entry"]];
  return result;
}

@end
@implementation JavaUtilHashtable_$1

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (BOOL)hasMoreElements {
  return NO;
}

- (id)nextElement {
  @throw [[[JavaUtilNoSuchElementException alloc] init] autorelease];
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

@end
@implementation JavaUtilHashtable_$2

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (BOOL)hasNext {
  return NO;
}

- (id)next {
  @throw [[[JavaUtilNoSuchElementException alloc] init] autorelease];
}

- (void)remove {
  @throw [[[JavaLangIllegalStateException alloc] init] autorelease];
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

@end
@implementation JavaUtilHashtable_$3

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return ((JavaUtilMapEntry *) nil_chk(entry))->value_;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

@end
@implementation JavaUtilHashtable_$4

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (int)size {
  return this$0_->elementCount_;
}

- (void)clear {
  [this$0_ clear];
}

- (BOOL)removeWithId:(id)object {
  if ([self containsWithId:object]) {
    [this$0_ removeWithId:[((id<JavaUtilMap_Entry>) nil_chk(object)) getKey]];
    return YES;
  }
  return NO;
}

- (BOOL)containsWithId:(id)object {
  JavaUtilHashtable_Entry *entry = [this$0_ getEntryWithId:[((id<JavaUtilMap_Entry>) nil_chk(object)) getKey]];
  return [nil_chk(object) isEqual:entry];
}

- (id<JavaUtilIterator>)iterator {
  return [[[JavaUtilHashtable_HashIterator alloc] initWithJavaUtilHashtable:this$0_ withJavaUtilMapEntry_Type:[[[JavaUtilHashtable_$4_$1 alloc] init] autorelease]] autorelease];
}

- (id)initWithJavaUtilHashtable:(JavaUtilHashtable *)outer$ {
  JavaUtilHashtable_$4_set_this$0_(self, outer$);
  return JreMemDebugAdd([super init]);
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilHashtable_$4_set_this$0_(self, nil);
  [super dealloc];
}

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id *)stackbuf count:(NSUInteger)len {
  return JreDefaultFastEnumeration(self, state, stackbuf, len);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:this$0_ name:@"this$0"]];
  return result;
}

@end
@implementation JavaUtilHashtable_$4_$1

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id<JavaUtilMap_Entry>)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return entry;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

@end
@implementation JavaUtilHashtable_$5

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return ((JavaUtilMapEntry *) nil_chk(entry))->key_;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

@end
@implementation JavaUtilHashtable_$6

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (BOOL)containsWithId:(id)object {
  return [this$0_ containsKeyWithId:object];
}

- (int)size {
  return this$0_->elementCount_;
}

- (void)clear {
  [this$0_ clear];
}

- (BOOL)removeWithId:(id)key {
  if ([this$0_ containsKeyWithId:key]) {
    [this$0_ removeWithId:key];
    return YES;
  }
  return NO;
}

- (id<JavaUtilIterator>)iterator {
  if ([self size] == 0) {
    return (id<JavaUtilIterator>) check_protocol_cast([JavaUtilHashtable EMPTY_ITERATOR], @protocol(JavaUtilIterator));
  }
  return [[[JavaUtilHashtable_HashEnumIterator alloc] initWithJavaUtilHashtable:this$0_ withJavaUtilMapEntry_Type:[[[JavaUtilHashtable_$6_$1 alloc] init] autorelease]] autorelease];
}

- (id)initWithJavaUtilHashtable:(JavaUtilHashtable *)outer$ {
  JavaUtilHashtable_$6_set_this$0_(self, outer$);
  return JreMemDebugAdd([super init]);
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilHashtable_$6_set_this$0_(self, nil);
  [super dealloc];
}

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id *)stackbuf count:(NSUInteger)len {
  return JreDefaultFastEnumeration(self, state, stackbuf, len);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:this$0_ name:@"this$0"]];
  return result;
}

@end
@implementation JavaUtilHashtable_$6_$1

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return ((JavaUtilMapEntry *) nil_chk(entry))->key_;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

@end
@implementation JavaUtilHashtable_$7

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (BOOL)containsWithId:(id)object {
  return [this$0_ containsWithId:object];
}

- (int)size {
  return this$0_->elementCount_;
}

- (void)clear {
  [this$0_ clear];
}

- (id<JavaUtilIterator>)iterator {
  return [[[JavaUtilHashtable_HashIterator alloc] initWithJavaUtilHashtable:this$0_ withJavaUtilMapEntry_Type:[[[JavaUtilHashtable_$7_$1 alloc] init] autorelease]] autorelease];
}

- (id)initWithJavaUtilHashtable:(JavaUtilHashtable *)outer$ {
  JavaUtilHashtable_$7_set_this$0_(self, outer$);
  return JreMemDebugAdd([super init]);
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilHashtable_$7_set_this$0_(self, nil);
  [super dealloc];
}

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id *)stackbuf count:(NSUInteger)len {
  return JreDefaultFastEnumeration(self, state, stackbuf, len);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:this$0_ name:@"this$0"]];
  return result;
}

@end
@implementation JavaUtilHashtable_$7_$1

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return ((JavaUtilMapEntry *) nil_chk(entry))->value_;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

@end
