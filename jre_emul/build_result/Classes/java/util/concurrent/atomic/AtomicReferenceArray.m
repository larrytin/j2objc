//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/concurrent/atomic/AtomicReferenceArray.java
//
//  Created by retechretech on 13-9-25.
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "java/io/Serializable.h"
#include "java/lang/StringBuilder.h"
#include "java/util/Arrays.h"
#include "java/util/concurrent/atomic/AtomicReferenceArray.h"
#include <libkern/OSAtomic.h>

@implementation JavaUtilConcurrentAtomicAtomicReferenceArray

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithInt:(int)length {
  if (self = [super init]) {
    JavaUtilConcurrentAtomicAtomicReferenceArray_set_array_(self, [IOSObjectArray arrayWithLength:length type:[IOSClass classWithClass:[NSObject class]]]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithNSObjectArray:(IOSObjectArray *)array {
  if (self = [super init]) {
    JavaUtilConcurrentAtomicAtomicReferenceArray_set_array_(self, [JavaUtilArrays copyOfWithNSObjectArray:array withInt:(int) [((IOSObjectArray *) nil_chk(array)) count] withIOSClass:[IOSObjectArray iosClassWithType:[IOSClass classWithClass:[NSObject class]]]]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (int)length {
  return (int) [((IOSObjectArray *) nil_chk(array_)) count];
}

- (id)getWithInt:(int)i {
  [JavaUtilConcurrentAtomicAtomicReferenceArray memoryBarrier];
  return (id) IOSObjectArray_Get(nil_chk(array_), i);
}

- (void)setWithInt:(int)i
            withId:(id)newValue {
  [JavaUtilConcurrentAtomicAtomicReferenceArray memoryBarrier];
  IOSObjectArray_Set(nil_chk(array_), i, newValue);
}

- (void)lazySetWithInt:(int)i
                withId:(id)newValue {
  [JavaUtilConcurrentAtomicAtomicReferenceArray memoryBarrier];
  IOSObjectArray_Set(nil_chk(array_), i, newValue);
}

- (id)getAndSetWithInt:(int)i
                withId:(id)newValue {
  while (YES) {
    id current = (id) IOSObjectArray_Get(nil_chk(array_), i);
    if ([self compareAndSetRawWithInt:i withId:current withId:newValue]) return current;
  }
}

- (BOOL)compareAndSetWithInt:(int)i
                      withId:(id)expect
                      withId:(id)update {
  return [self compareAndSetRawWithInt:i withId:expect withId:update];
}

- (BOOL)weakCompareAndSetWithInt:(int)i
                          withId:(id)expect
                          withId:(id)update {
  return [self compareAndSetWithInt:i withId:expect withId:update];
}

- (NSString *)description {
  int iMax = (int) [((IOSObjectArray *) nil_chk(array_)) count] - 1;
  if (iMax == -1) return @"[]";
  JavaLangStringBuilder *b = [[[JavaLangStringBuilder alloc] init] autorelease];
  [b appendWithChar:'['];
  for (int i = 0; ; i++) {
    [b appendWithId:IOSObjectArray_Get(array_, i)];
    if (i == iMax) return [((JavaLangStringBuilder *) nil_chk([b appendWithChar:']'])) description];
    [((JavaLangStringBuilder *) nil_chk([b appendWithChar:','])) appendWithChar:' '];
  }
}

+ (void)memoryBarrier {
  OSMemoryBarrier();
}

- (BOOL)compareAndSetRawWithInt:(int)i
                         withId:(id)expect
                         withId:(id)update {
  OSSpinLock lock = OS_SPINLOCK_INIT;
  OSSpinLockLock(&lock);
  id current = [array_ objectAtIndex:i];
  BOOL swap = current == expect;
  if (swap) {
    [array_ replaceObjectAtIndex:i withObject:update];
  }
  OSSpinLockUnlock(&lock);
  return swap;
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilConcurrentAtomicAtomicReferenceArray_set_array_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaUtilConcurrentAtomicAtomicReferenceArray *)other {
  [super copyAllFieldsTo:other];
  JavaUtilConcurrentAtomicAtomicReferenceArray_set_array_(other, array_);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:array_ name:@"array"]];
  return result;
}

@end
