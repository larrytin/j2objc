//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//
//  Created by Larry Tin <dev@goodow.com>
//

#include "IOSBooleanArray.h"
#include "java/util/concurrent/atomic/AtomicMarkableReference.h"
#include <libkern/OSAtomic.h>

@implementation JavaUtilConcurrentAtomicAtomicMarkableReference

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithId:(id)initialRef
     withBoolean:(BOOL)initialMark {
  if (self = [super init]) {
    JavaUtilConcurrentAtomicAtomicMarkableReference_set_pair_(self, [JavaUtilConcurrentAtomicAtomicMarkableReference_Pair ofWithId:initialRef withBoolean:initialMark]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)getReference {
  return ((JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *) nil_chk(pair_))->reference_;
}

- (BOOL)isMarked {
  return ((JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *) nil_chk(pair_))->mark_;
}

- (id)getWithBooleanArray:(IOSBooleanArray *)markHolder {
  JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *pair = self->pair_;
  (*IOSBooleanArray_GetRef(nil_chk(markHolder), 0)) = ((JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *) nil_chk(pair))->mark_;
  return pair->reference_;
}

- (BOOL)weakCompareAndSetWithId:(id)expectedReference
                         withId:(id)newReference
                    withBoolean:(BOOL)expectedMark
                    withBoolean:(BOOL)newMark {
  return [self compareAndSetWithId:expectedReference withId:newReference withBoolean:expectedMark withBoolean:newMark];
}

- (BOOL)compareAndSetWithId:(id)expectedReference
                     withId:(id)newReference
                withBoolean:(BOOL)expectedMark
                withBoolean:(BOOL)newMark {
  JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *current = pair_;
  return expectedReference == ((JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *) nil_chk(current))->reference_ && expectedMark == current->mark_ && ((newReference == current->reference_ && newMark == current->mark_) || [self casPairWithJavaUtilConcurrentAtomicAtomicMarkableReference_Pair:current withJavaUtilConcurrentAtomicAtomicMarkableReference_Pair:[JavaUtilConcurrentAtomicAtomicMarkableReference_Pair ofWithId:newReference withBoolean:newMark]]);
}

- (void)setWithId:(id)newReference
      withBoolean:(BOOL)newMark {
  JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *current = pair_;
  if (newReference != ((JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *) nil_chk(current))->reference_ || newMark != current->mark_) JavaUtilConcurrentAtomicAtomicMarkableReference_set_pair_(self, [JavaUtilConcurrentAtomicAtomicMarkableReference_Pair ofWithId:newReference withBoolean:newMark]);
}

- (BOOL)attemptMarkWithId:(id)expectedReference
              withBoolean:(BOOL)newMark {
  JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *current = pair_;
  return expectedReference == ((JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *) nil_chk(current))->reference_ && (newMark == current->mark_ || [self casPairWithJavaUtilConcurrentAtomicAtomicMarkableReference_Pair:current withJavaUtilConcurrentAtomicAtomicMarkableReference_Pair:[JavaUtilConcurrentAtomicAtomicMarkableReference_Pair ofWithId:expectedReference withBoolean:newMark]]);
}

- (BOOL)casPairWithJavaUtilConcurrentAtomicAtomicMarkableReference_Pair:(JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *)cmp
               withJavaUtilConcurrentAtomicAtomicMarkableReference_Pair:(JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *)val {
  #if __has_feature(objc_arc)
  void * volatile tmp = (__bridge void * volatile) pair_;
  return OSAtomicCompareAndSwapPtrBarrier((__bridge void *) cmp, (__bridge void *) val, &tmp);
  #else
  return OSAtomicCompareAndSwapPtrBarrier(cmp, val, (void * volatile *) &pair_);
  #endif
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilConcurrentAtomicAtomicMarkableReference_set_pair_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaUtilConcurrentAtomicAtomicMarkableReference *)other {
  [super copyAllFieldsTo:other];
  JavaUtilConcurrentAtomicAtomicMarkableReference_set_pair_(other, pair_);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:pair_ name:@"pair"]];
  return result;
}

@end
@implementation JavaUtilConcurrentAtomicAtomicMarkableReference_Pair

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithId:(id)reference
     withBoolean:(BOOL)mark {
  if (self = [super init]) {
    JavaUtilConcurrentAtomicAtomicMarkableReference_Pair_set_reference_(self, reference);
    self->mark_ = mark;
    JreMemDebugAdd(self);
  }
  return self;
}

+ (JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *)ofWithId:(id)reference
                                                       withBoolean:(BOOL)mark {
  return [[[JavaUtilConcurrentAtomicAtomicMarkableReference_Pair alloc] initWithId:reference withBoolean:mark] autorelease];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilConcurrentAtomicAtomicMarkableReference_Pair_set_reference_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaUtilConcurrentAtomicAtomicMarkableReference_Pair *)other {
  [super copyAllFieldsTo:other];
  other->mark_ = mark_;
  JavaUtilConcurrentAtomicAtomicMarkableReference_Pair_set_reference_(other, reference_);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:reference_ name:@"reference"]];
  return result;
}

@end
