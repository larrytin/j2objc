//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/concurrent/atomic/AtomicStampedReference.java
//
//  Created by retechretech on 13-9-25.
//

#include "IOSIntArray.h"
#include "java/util/concurrent/atomic/AtomicStampedReference.h"
#include <libkern/OSAtomic.h>

@implementation JavaUtilConcurrentAtomicAtomicStampedReference

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithId:(id)initialRef
         withInt:(int)initialStamp {
  if (self = [super init]) {
    JavaUtilConcurrentAtomicAtomicStampedReference_set_pair_(self, [JavaUtilConcurrentAtomicAtomicStampedReference_Pair ofWithId:initialRef withInt:initialStamp]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)getReference {
  return ((JavaUtilConcurrentAtomicAtomicStampedReference_Pair *) nil_chk(pair_))->reference_;
}

- (int)getStamp {
  return ((JavaUtilConcurrentAtomicAtomicStampedReference_Pair *) nil_chk(pair_))->stamp_;
}

- (id)getWithIntArray:(IOSIntArray *)stampHolder {
  JavaUtilConcurrentAtomicAtomicStampedReference_Pair *pair = self->pair_;
  (*IOSIntArray_GetRef(nil_chk(stampHolder), 0)) = ((JavaUtilConcurrentAtomicAtomicStampedReference_Pair *) nil_chk(pair))->stamp_;
  return pair->reference_;
}

- (BOOL)weakCompareAndSetWithId:(id)expectedReference
                         withId:(id)newReference
                        withInt:(int)expectedStamp
                        withInt:(int)newStamp {
  return [self compareAndSetWithId:expectedReference withId:newReference withInt:expectedStamp withInt:newStamp];
}

- (BOOL)compareAndSetWithId:(id)expectedReference
                     withId:(id)newReference
                    withInt:(int)expectedStamp
                    withInt:(int)newStamp {
  JavaUtilConcurrentAtomicAtomicStampedReference_Pair *current = pair_;
  return expectedReference == ((JavaUtilConcurrentAtomicAtomicStampedReference_Pair *) nil_chk(current))->reference_ && expectedStamp == current->stamp_ && ((newReference == current->reference_ && newStamp == current->stamp_) || [self casPairWithJavaUtilConcurrentAtomicAtomicStampedReference_Pair:current withJavaUtilConcurrentAtomicAtomicStampedReference_Pair:[JavaUtilConcurrentAtomicAtomicStampedReference_Pair ofWithId:newReference withInt:newStamp]]);
}

- (void)setWithId:(id)newReference
          withInt:(int)newStamp {
  JavaUtilConcurrentAtomicAtomicStampedReference_Pair *current = pair_;
  if (newReference != ((JavaUtilConcurrentAtomicAtomicStampedReference_Pair *) nil_chk(current))->reference_ || newStamp != current->stamp_) JavaUtilConcurrentAtomicAtomicStampedReference_set_pair_(self, [JavaUtilConcurrentAtomicAtomicStampedReference_Pair ofWithId:newReference withInt:newStamp]);
}

- (BOOL)attemptStampWithId:(id)expectedReference
                   withInt:(int)newStamp {
  JavaUtilConcurrentAtomicAtomicStampedReference_Pair *current = pair_;
  return expectedReference == ((JavaUtilConcurrentAtomicAtomicStampedReference_Pair *) nil_chk(current))->reference_ && (newStamp == current->stamp_ || [self casPairWithJavaUtilConcurrentAtomicAtomicStampedReference_Pair:current withJavaUtilConcurrentAtomicAtomicStampedReference_Pair:[JavaUtilConcurrentAtomicAtomicStampedReference_Pair ofWithId:expectedReference withInt:newStamp]]);
}

- (BOOL)casPairWithJavaUtilConcurrentAtomicAtomicStampedReference_Pair:(JavaUtilConcurrentAtomicAtomicStampedReference_Pair *)cmp
               withJavaUtilConcurrentAtomicAtomicStampedReference_Pair:(JavaUtilConcurrentAtomicAtomicStampedReference_Pair *)val {
  #if __has_feature(objc_arc)
  void * volatile tmp = (__bridge void * volatile) pair_;
  return OSAtomicCompareAndSwapPtrBarrier((__bridge void *) cmp, (__bridge void *) val, &tmp);
  #else
  return OSAtomicCompareAndSwapPtrBarrier(cmp, val, (void * volatile *) &pair_);
  #endif
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilConcurrentAtomicAtomicStampedReference_set_pair_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaUtilConcurrentAtomicAtomicStampedReference *)other {
  [super copyAllFieldsTo:other];
  JavaUtilConcurrentAtomicAtomicStampedReference_set_pair_(other, pair_);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:pair_ name:@"pair"]];
  return result;
}

@end
@implementation JavaUtilConcurrentAtomicAtomicStampedReference_Pair

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithId:(id)reference
         withInt:(int)stamp {
  if (self = [super init]) {
    JavaUtilConcurrentAtomicAtomicStampedReference_Pair_set_reference_(self, reference);
    self->stamp_ = stamp;
    JreMemDebugAdd(self);
  }
  return self;
}

+ (JavaUtilConcurrentAtomicAtomicStampedReference_Pair *)ofWithId:(id)reference
                                                          withInt:(int)stamp {
  return [[[JavaUtilConcurrentAtomicAtomicStampedReference_Pair alloc] initWithId:reference withInt:stamp] autorelease];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilConcurrentAtomicAtomicStampedReference_Pair_set_reference_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaUtilConcurrentAtomicAtomicStampedReference_Pair *)other {
  [super copyAllFieldsTo:other];
  JavaUtilConcurrentAtomicAtomicStampedReference_Pair_set_reference_(other, reference_);
  other->stamp_ = stamp_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:reference_ name:@"reference"]];
  return result;
}

@end
