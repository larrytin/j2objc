//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/util/IdentityHashMap.java
//
//  Created by retechretech on 13-9-25.
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "java/lang/CloneNotSupportedException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/System.h"
#include "java/util/AbstractMap.h"
#include "java/util/Collection.h"
#include "java/util/ConcurrentModificationException.h"
#include "java/util/IdentityHashMap.h"
#include "java/util/Iterator.h"
#include "java/util/Map.h"
#include "java/util/MapEntry.h"
#include "java/util/NoSuchElementException.h"
#include "java/util/Set.h"

@implementation JavaUtilIdentityHashMap

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaUtilIdentityHashMap_NULL_OBJECT_ name:@"JavaUtilIdentityHashMap_NULL_OBJECT_"]];
  return result;
}

static id JavaUtilIdentityHashMap_NULL_OBJECT_;

+ (id)NULL_OBJECT {
  return JavaUtilIdentityHashMap_NULL_OBJECT_;
}

- (id)init {
  return JreMemDebugAdd([self initJavaUtilIdentityHashMapWithInt:JavaUtilIdentityHashMap_DEFAULT_MAX_SIZE]);
}

- (id)initJavaUtilIdentityHashMapWithInt:(int)maxSize {
  if (self = [super init]) {
    modCount_ = 0;
    if (maxSize >= 0) {
      self->size__ = 0;
      threshold_ = [self getThresholdWithInt:maxSize];
      JavaUtilIdentityHashMap_set_elementData_(self, [self newElementArrayWithInt:[self computeElementArraySize]]);
    }
    else {
      @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithInt:(int)maxSize {
  return [self initJavaUtilIdentityHashMapWithInt:maxSize];
}

- (int)getThresholdWithInt:(int)maxSize {
  return maxSize > 3 ? maxSize : 3;
}

- (int)computeElementArraySize {
  int arraySize = (int) (((long long int) threshold_ * 10000) / JavaUtilIdentityHashMap_loadFactor) * 2;
  return arraySize < 0 ? -arraySize : arraySize;
}

- (IOSObjectArray *)newElementArrayWithInt:(int)s {
  return [IOSObjectArray arrayWithLength:s type:[IOSClass classWithClass:[NSObject class]]];
}

- (id)initWithJavaUtilMap:(id<JavaUtilMap>)map {
  if (self = [self initJavaUtilIdentityHashMapWithInt:[((id<JavaUtilMap>) nil_chk(map)) size] < 6 ? 11 : [map size] * 2]) {
    [self putAllImplWithJavaUtilMap:map];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)massageValueWithId:(id)value {
  return (id) ((value == JavaUtilIdentityHashMap_NULL_OBJECT_) ? nil : value);
}

- (void)clear {
  size__ = 0;
  for (int i = 0; i < (int) [((IOSObjectArray *) nil_chk(elementData_)) count]; i++) {
    IOSObjectArray_Set(elementData_, i, nil);
  }
  modCount_++;
}

- (BOOL)containsKeyWithId:(id)key {
  if (key == nil) {
    key = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  int index = [JavaUtilIdentityHashMap findIndexWithId:key withNSObjectArray:elementData_];
  return IOSObjectArray_Get(nil_chk(elementData_), index) == key;
}

- (BOOL)containsValueWithId:(id)value {
  if (value == nil) {
    value = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  for (int i = 1; i < (int) [((IOSObjectArray *) nil_chk(elementData_)) count]; i = i + 2) {
    if (IOSObjectArray_Get(elementData_, i) == value) {
      return YES;
    }
  }
  return NO;
}

- (id)getWithId:(id)key {
  if (key == nil) {
    key = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  int index = [JavaUtilIdentityHashMap findIndexWithId:key withNSObjectArray:elementData_];
  if (IOSObjectArray_Get(nil_chk(elementData_), index) == key) {
    id result = IOSObjectArray_Get(elementData_, index + 1);
    return [self massageValueWithId:result];
  }
  return nil;
}

- (JavaUtilIdentityHashMap_IdentityHashMapEntry *)getEntryWithId:(id)key {
  if (key == nil) {
    key = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  int index = [JavaUtilIdentityHashMap findIndexWithId:key withNSObjectArray:elementData_];
  if (IOSObjectArray_Get(nil_chk(elementData_), index) == key) {
    return [self getEntryWithInt:index];
  }
  return nil;
}

- (JavaUtilIdentityHashMap_IdentityHashMapEntry *)getEntryWithInt:(int)index {
  return [[[JavaUtilIdentityHashMap_IdentityHashMapEntry alloc] initWithId:(id) IOSObjectArray_Get(nil_chk(elementData_), index) withId:(id) IOSObjectArray_Get(elementData_, index + 1) withNSObjectArray:elementData_] autorelease];
}

+ (int)findIndexWithId:(id)key
     withNSObjectArray:(IOSObjectArray *)array {
  int length = (int) [((IOSObjectArray *) nil_chk(array)) count];
  int index = [JavaUtilIdentityHashMap getModuloHashWithId:key withInt:length];
  int last = (index + length - 2) % length;
  while (index != last) {
    if (IOSObjectArray_Get(array, index) == key || (IOSObjectArray_Get(array, index) == nil)) {
      break;
    }
    index = (index + 2) % length;
  }
  return index;
}

+ (int)getModuloHashWithId:(id)key
                   withInt:(int)length {
  return (([JavaLangSystem identityHashCodeWithId:key] & (int) 0x7FFFFFFF) % (length / 2)) * 2;
}

- (id)putWithId:(id)key
         withId:(id)value {
  id _key = key;
  id _value = value;
  if (_key == nil) {
    _key = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  if (_value == nil) {
    _value = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  int index = [JavaUtilIdentityHashMap findIndexWithId:_key withNSObjectArray:elementData_];
  if (IOSObjectArray_Get(nil_chk(elementData_), index) != _key) {
    modCount_++;
    if (++size__ > threshold_) {
      [self rehash];
      index = [JavaUtilIdentityHashMap findIndexWithId:_key withNSObjectArray:elementData_];
    }
    IOSObjectArray_Set(elementData_, index, _key);
    IOSObjectArray_Set(elementData_, index + 1, nil);
  }
  id result = IOSObjectArray_Get(elementData_, index + 1);
  IOSObjectArray_Set(elementData_, index + 1, _value);
  return [self massageValueWithId:result];
}

- (void)putAllWithJavaUtilMap:(id<JavaUtilMap>)map {
  [self putAllImplWithJavaUtilMap:map];
}

- (void)rehash {
  int newlength = (int) [((IOSObjectArray *) nil_chk(elementData_)) count] << 1;
  if (newlength == 0) {
    newlength = 1;
  }
  IOSObjectArray *newData = [self newElementArrayWithInt:newlength];
  for (int i = 0; i < (int) [elementData_ count]; i = i + 2) {
    id key = IOSObjectArray_Get(elementData_, i);
    if (key != nil) {
      int index = [JavaUtilIdentityHashMap findIndexWithId:key withNSObjectArray:newData];
      IOSObjectArray_Set(nil_chk(newData), index, key);
      IOSObjectArray_Set(newData, index + 1, IOSObjectArray_Get(elementData_, i + 1));
    }
  }
  JavaUtilIdentityHashMap_set_elementData_(self, newData);
  [self computeMaxSize];
}

- (void)computeMaxSize {
  threshold_ = (int) ((long long int) ((int) [((IOSObjectArray *) nil_chk(elementData_)) count] / 2) * JavaUtilIdentityHashMap_loadFactor / 10000);
}

- (id)removeWithId:(id)key {
  if (key == nil) {
    key = JavaUtilIdentityHashMap_NULL_OBJECT_;
  }
  BOOL hashedOk;
  int index, next, hash_;
  id result, object;
  index = next = [JavaUtilIdentityHashMap findIndexWithId:key withNSObjectArray:elementData_];
  if (IOSObjectArray_Get(nil_chk(elementData_), index) != key) {
    return nil;
  }
  result = IOSObjectArray_Get(elementData_, index + 1);
  int length = (int) [elementData_ count];
  while (YES) {
    next = (next + 2) % length;
    object = IOSObjectArray_Get(elementData_, next);
    if (object == nil) {
      break;
    }
    hash_ = [JavaUtilIdentityHashMap getModuloHashWithId:object withInt:length];
    hashedOk = hash_ > index;
    if (next < index) {
      hashedOk = hashedOk || (hash_ <= next);
    }
    else {
      hashedOk = hashedOk && (hash_ <= next);
    }
    if (!hashedOk) {
      IOSObjectArray_Set(elementData_, index, object);
      IOSObjectArray_Set(elementData_, index + 1, IOSObjectArray_Get(elementData_, next + 1));
      index = next;
    }
  }
  size__--;
  modCount_++;
  IOSObjectArray_Set(elementData_, index, nil);
  IOSObjectArray_Set(elementData_, index + 1, nil);
  return [self massageValueWithId:result];
}

- (id<JavaUtilSet>)entrySet {
  return [[[JavaUtilIdentityHashMap_IdentityHashMapEntrySet alloc] initWithJavaUtilIdentityHashMap:self] autorelease];
}

- (id<JavaUtilSet>)keySet {
  if (keySet__ == nil) {
    JavaUtilAbstractMap_set_keySet__(self, [[[JavaUtilIdentityHashMap_KeySet alloc] initWithJavaUtilIdentityHashMap:self] autorelease]);
  }
  return keySet__;
}

- (id<JavaUtilCollection>)values {
  if (valuesCollection_ == nil) {
    JavaUtilAbstractMap_set_valuesCollection_(self, [[[JavaUtilIdentityHashMap_ValuesCollection alloc] initWithJavaUtilIdentityHashMap:self] autorelease]);
  }
  return valuesCollection_;
}

- (BOOL)isEqual:(id)object {
  if (self == object) {
    return YES;
  }
  if ([object conformsToProtocol: @protocol(JavaUtilMap)]) {
    id<JavaUtilMap> map = (id<JavaUtilMap>) check_protocol_cast(object, @protocol(JavaUtilMap));
    if ([self size] != [((id<JavaUtilMap>) nil_chk(map)) size]) {
      return NO;
    }
    id<JavaUtilSet> set = [self entrySet];
    return [((id<JavaUtilSet>) nil_chk(set)) isEqual:[map entrySet]];
  }
  return NO;
}

- (id)clone {
  @try {
    JavaUtilIdentityHashMap *cloneHashMap = (JavaUtilIdentityHashMap *) check_class_cast([super clone], [JavaUtilIdentityHashMap class]);
    JavaUtilIdentityHashMap_set_elementData_(nil_chk(cloneHashMap), [self newElementArrayWithInt:(int) [((IOSObjectArray *) nil_chk(elementData_)) count]]);
    [JavaLangSystem arraycopyWithId:elementData_ withInt:0 withId:cloneHashMap->elementData_ withInt:0 withInt:(int) [((IOSObjectArray *) nil_chk(elementData_)) count]];
    return cloneHashMap;
  }
  @catch (JavaLangCloneNotSupportedException *e) {
    return nil;
  }
}

- (BOOL)isEmpty {
  return size__ == 0;
}

- (int)size {
  return size__;
}

- (void)putAllImplWithJavaUtilMap:(id<JavaUtilMap>)map {
  if ([((id<JavaUtilMap>) nil_chk(map)) entrySet] != nil) {
    [super putAllWithJavaUtilMap:map];
  }
}

+ (void)initialize {
  if (self == [JavaUtilIdentityHashMap class]) {
    JreOperatorRetainedAssign(&JavaUtilIdentityHashMap_NULL_OBJECT_, nil, [[[NSObject alloc] init] autorelease]);
  }
}

- (id)copyWithZone:(NSZone *)zone {
  return [[self clone] retain];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilIdentityHashMap_set_elementData_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaUtilIdentityHashMap *)other {
  [super copyAllFieldsTo:other];
  JavaUtilIdentityHashMap_set_elementData_(other, elementData_);
  other->modCount_ = modCount_;
  other->size__ = size__;
  other->threshold_ = threshold_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:elementData_ name:@"elementData"]];
  return result;
}

@end
@implementation JavaUtilIdentityHashMap_IdentityHashMapEntry

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithId:(id)theKey
          withId:(id)theValue
withNSObjectArray:(IOSObjectArray *)elementData {
  if (self = [super initWithId:(id) theKey == [JavaUtilIdentityHashMap NULL_OBJECT] ? nil : theKey withId:(id) theValue == [JavaUtilIdentityHashMap NULL_OBJECT] ? nil : theValue]) {
    JavaUtilIdentityHashMap_IdentityHashMapEntry_set_iKey_(self, theKey);
    JavaUtilIdentityHashMap_IdentityHashMapEntry_set_elementData_(self, elementData);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)clone {
  return [super clone];
}

- (BOOL)isEqual:(id)object {
  if (self == object) {
    return YES;
  }
  if ([object conformsToProtocol: @protocol(JavaUtilMap_Entry)]) {
    id<JavaUtilMap_Entry> entry = (id<JavaUtilMap_Entry>) check_protocol_cast(object, @protocol(JavaUtilMap_Entry));
    return (key_ == [((id<JavaUtilMap_Entry>) nil_chk(entry)) getKey]) && (value_ == [entry getValue]);
  }
  return NO;
}

- (NSUInteger)hash {
  return [JavaLangSystem identityHashCodeWithId:key_] ^ [JavaLangSystem identityHashCodeWithId:value_];
}

- (NSString *)description {
  return [NSString stringWithFormat:@"%@=%@", key_, value_];
}

- (id)setValueWithId:(id)object {
  int index = [JavaUtilIdentityHashMap findIndexWithId:iKey_ withNSObjectArray:elementData_];
  if (IOSObjectArray_Get(nil_chk(elementData_), index) == key_) {
    IOSObjectArray_Set(elementData_, index + 1, object);
  }
  return [super setValueWithId:object];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilIdentityHashMap_IdentityHashMapEntry_set_elementData_(self, nil);
  JavaUtilIdentityHashMap_IdentityHashMapEntry_set_iKey_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaUtilIdentityHashMap_IdentityHashMapEntry *)other {
  [super copyAllFieldsTo:other];
  JavaUtilIdentityHashMap_IdentityHashMapEntry_set_elementData_(other, elementData_);
  JavaUtilIdentityHashMap_IdentityHashMapEntry_set_iKey_(other, iKey_);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:iKey_ name:@"iKey"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:elementData_ name:@"elementData"]];
  return result;
}

@end
@implementation JavaUtilIdentityHashMap_IdentityHashMapIterator

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithJavaUtilMapEntry_Type:(id<JavaUtilMapEntry_Type>)value
        withJavaUtilIdentityHashMap:(JavaUtilIdentityHashMap *)hm {
  if (self = [super init]) {
    position_ = 0;
    lastPosition_ = 0;
    canRemove_ = NO;
    JavaUtilIdentityHashMap_IdentityHashMapIterator_set_associatedMap_(self, hm);
    JavaUtilIdentityHashMap_IdentityHashMapIterator_set_type_(self, value);
    expectedModCount_ = ((JavaUtilIdentityHashMap *) nil_chk(hm))->modCount_;
    JreMemDebugAdd(self);
  }
  return self;
}

- (BOOL)hasNext {
  while (position_ < (int) [((IOSObjectArray *) nil_chk(((JavaUtilIdentityHashMap *) nil_chk(associatedMap_))->elementData_)) count]) {
    if (IOSObjectArray_Get(associatedMap_->elementData_, position_) == nil) {
      position_ += 2;
    }
    else {
      return YES;
    }
  }
  return NO;
}

- (void)checkConcurrentMod {
  if (expectedModCount_ != ((JavaUtilIdentityHashMap *) nil_chk(associatedMap_))->modCount_) {
    @throw [[[JavaUtilConcurrentModificationException alloc] init] autorelease];
  }
}

+ (IOSObjectArray *)__exceptions_checkConcurrentMod {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaUtilConcurrentModificationException getClass] } count:1 type:[IOSClass getClass]];
}

- (id)next {
  [self checkConcurrentMod];
  if (![self hasNext]) {
    @throw [[[JavaUtilNoSuchElementException alloc] init] autorelease];
  }
  JavaUtilIdentityHashMap_IdentityHashMapEntry *result = [((JavaUtilIdentityHashMap *) nil_chk(associatedMap_)) getEntryWithInt:position_];
  lastPosition_ = position_;
  position_ += 2;
  canRemove_ = YES;
  return [((id<JavaUtilMapEntry_Type>) nil_chk(type_)) getWithJavaUtilMapEntry:result];
}

- (void)remove {
  [self checkConcurrentMod];
  if (!canRemove_) {
    @throw [[[JavaLangIllegalStateException alloc] init] autorelease];
  }
  canRemove_ = NO;
  [associatedMap_ removeWithId:IOSObjectArray_Get(nil_chk(((JavaUtilIdentityHashMap *) nil_chk(associatedMap_))->elementData_), lastPosition_)];
  position_ = lastPosition_;
  expectedModCount_++;
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilIdentityHashMap_IdentityHashMapIterator_set_type_(self, nil);
  JavaUtilIdentityHashMap_IdentityHashMapIterator_set_associatedMap_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaUtilIdentityHashMap_IdentityHashMapIterator *)other {
  [super copyAllFieldsTo:other];
  JavaUtilIdentityHashMap_IdentityHashMapIterator_set_associatedMap_(other, associatedMap_);
  other->canRemove_ = canRemove_;
  other->expectedModCount_ = expectedModCount_;
  other->lastPosition_ = lastPosition_;
  other->position_ = position_;
  JavaUtilIdentityHashMap_IdentityHashMapIterator_set_type_(other, type_);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:associatedMap_ name:@"associatedMap"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:type_ name:@"type"]];
  return result;
}

@end
@implementation JavaUtilIdentityHashMap_IdentityHashMapEntrySet

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithJavaUtilIdentityHashMap:(JavaUtilIdentityHashMap *)hm {
  if (self = [super init]) {
    JavaUtilIdentityHashMap_IdentityHashMapEntrySet_set_associatedMap_(self, hm);
    JreMemDebugAdd(self);
  }
  return self;
}

- (JavaUtilIdentityHashMap *)hashMap {
  return associatedMap_;
}

- (int)size {
  return ((JavaUtilIdentityHashMap *) nil_chk(associatedMap_))->size__;
}

- (void)clear {
  [((JavaUtilIdentityHashMap *) nil_chk(associatedMap_)) clear];
}

- (BOOL)removeWithId:(id)object {
  if ([self containsWithId:object]) {
    [((JavaUtilIdentityHashMap *) nil_chk(associatedMap_)) removeWithId:[((id<JavaUtilMap_Entry>) nil_chk(object)) getKey]];
    return YES;
  }
  return NO;
}

- (BOOL)containsWithId:(id)object {
  if ([object conformsToProtocol: @protocol(JavaUtilMap_Entry)]) {
    JavaUtilIdentityHashMap_IdentityHashMapEntry *entry = [((JavaUtilIdentityHashMap *) nil_chk(associatedMap_)) getEntryWithId:[((id<JavaUtilMap_Entry>) nil_chk(object)) getKey]];
    return entry != nil && [entry isEqual:object];
  }
  return NO;
}

- (id<JavaUtilIterator>)iterator {
  return [[[JavaUtilIdentityHashMap_IdentityHashMapIterator alloc] initWithJavaUtilMapEntry_Type:[[[JavaUtilIdentityHashMap_IdentityHashMapEntrySet_$1 alloc] init] autorelease] withJavaUtilIdentityHashMap:associatedMap_] autorelease];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaUtilIdentityHashMap_IdentityHashMapEntrySet_set_associatedMap_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaUtilIdentityHashMap_IdentityHashMapEntrySet *)other {
  [super copyAllFieldsTo:other];
  JavaUtilIdentityHashMap_IdentityHashMapEntrySet_set_associatedMap_(other, associatedMap_);
}

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id *)stackbuf count:(NSUInteger)len {
  return JreDefaultFastEnumeration(self, state, stackbuf, len);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:associatedMap_ name:@"associatedMap"]];
  return result;
}

@end
@implementation JavaUtilIdentityHashMap_IdentityHashMapEntrySet_$1

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id<JavaUtilMap_Entry>)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return entry;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

@end
@implementation JavaUtilIdentityHashMap_KeySet

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (BOOL)containsWithId:(id)object {
  return [this$0_ containsKeyWithId:object];
}

- (int)size {
  return [this$0_ size];
}

- (void)clear {
  [this$0_ clear];
}

- (BOOL)removeWithId:(id)key {
  if ([this$0_ containsKeyWithId:key]) {
    [this$0_ removeWithId:key];
    return YES;
  }
  return NO;
}

- (id<JavaUtilIterator>)iterator {
  return [[[JavaUtilIdentityHashMap_IdentityHashMapIterator alloc] initWithJavaUtilMapEntry_Type:[[[JavaUtilIdentityHashMap_KeySet_$1 alloc] init] autorelease] withJavaUtilIdentityHashMap:this$0_] autorelease];
}

- (id)initWithJavaUtilIdentityHashMap:(JavaUtilIdentityHashMap *)outer$ {
  this$0_ = outer$;
  return JreMemDebugAdd([super init]);
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id *)stackbuf count:(NSUInteger)len {
  return JreDefaultFastEnumeration(self, state, stackbuf, len);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  return result;
}

@end
@implementation JavaUtilIdentityHashMap_KeySet_$1

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return ((JavaUtilMapEntry *) nil_chk(entry))->key_;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

@end
@implementation JavaUtilIdentityHashMap_ValuesCollection

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (BOOL)containsWithId:(id)object {
  return [this$0_ containsValueWithId:object];
}

- (int)size {
  return [this$0_ size];
}

- (void)clear {
  [this$0_ clear];
}

- (id<JavaUtilIterator>)iterator {
  return [[[JavaUtilIdentityHashMap_IdentityHashMapIterator alloc] initWithJavaUtilMapEntry_Type:[[[JavaUtilIdentityHashMap_ValuesCollection_$1 alloc] init] autorelease] withJavaUtilIdentityHashMap:this$0_] autorelease];
}

- (BOOL)removeWithId:(id)object {
  id<JavaUtilIterator> it = [self iterator];
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    if (object == [it next]) {
      [it remove];
      return YES;
    }
  }
  return NO;
}

- (id)initWithJavaUtilIdentityHashMap:(JavaUtilIdentityHashMap *)outer$ {
  this$0_ = outer$;
  return JreMemDebugAdd([super init]);
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [super dealloc];
}

- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(__unsafe_unretained id *)stackbuf count:(NSUInteger)len {
  return JreDefaultFastEnumeration(self, state, stackbuf, len);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  return result;
}

@end
@implementation JavaUtilIdentityHashMap_ValuesCollection_$1

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)getWithJavaUtilMapEntry:(JavaUtilMapEntry *)entry {
  return ((JavaUtilMapEntry *) nil_chk(entry))->value_;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

@end
