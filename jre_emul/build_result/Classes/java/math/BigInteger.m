//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/math/src/main/java/java/math/BigInteger.java
//
//  Created by retechretech on 13-9-25.
//

#include "IOSByteArray.h"
#include "IOSClass.h"
#include "IOSIntArray.h"
#include "IOSObjectArray.h"
#include "java/lang/ArithmeticException.h"
#include "java/lang/Character.h"
#include "java/lang/ClassCastException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/System.h"
#include "java/math/BigInteger.h"
#include "java/math/BitLevel.h"
#include "java/math/Conversion.h"
#include "java/math/Division.h"
#include "java/math/Elementary.h"
#include "java/math/Logical.h"
#include "java/math/Multiplication.h"
#include "java/math/Primality.h"
#include "java/util/Random.h"

@implementation JavaMathBigInteger

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaMathBigInteger_ZERO_ name:@"JavaMathBigInteger_ZERO_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaMathBigInteger_ONE_ name:@"JavaMathBigInteger_ONE_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaMathBigInteger_TEN_ name:@"JavaMathBigInteger_TEN_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaMathBigInteger_MINUS_ONE_ name:@"JavaMathBigInteger_MINUS_ONE_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaMathBigInteger_SMALL_VALUES_ name:@"JavaMathBigInteger_SMALL_VALUES_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaMathBigInteger_TWO_POWS_ name:@"JavaMathBigInteger_TWO_POWS_"]];
  return result;
}

static JavaMathBigInteger * JavaMathBigInteger_ZERO_;
static JavaMathBigInteger * JavaMathBigInteger_ONE_;
static JavaMathBigInteger * JavaMathBigInteger_TEN_;
static JavaMathBigInteger * JavaMathBigInteger_MINUS_ONE_;
static IOSObjectArray * JavaMathBigInteger_SMALL_VALUES_;
static IOSObjectArray * JavaMathBigInteger_TWO_POWS_;

+ (JavaMathBigInteger *)ZERO {
  return JavaMathBigInteger_ZERO_;
}

+ (JavaMathBigInteger *)ONE {
  return JavaMathBigInteger_ONE_;
}

+ (JavaMathBigInteger *)TEN {
  return JavaMathBigInteger_TEN_;
}

+ (JavaMathBigInteger *)MINUS_ONE {
  return JavaMathBigInteger_MINUS_ONE_;
}

+ (int)EQUALS {
  return JavaMathBigInteger_EQUALS;
}

+ (int)GREATER {
  return JavaMathBigInteger_GREATER;
}

+ (int)LESS {
  return JavaMathBigInteger_LESS;
}

+ (IOSObjectArray *)SMALL_VALUES {
  return JavaMathBigInteger_SMALL_VALUES_;
}

+ (IOSObjectArray *)TWO_POWS {
  return JavaMathBigInteger_TWO_POWS_;
}

- (id)initWithInt:(int)numBits
withJavaUtilRandom:(JavaUtilRandom *)rnd {
  if (self = [super init]) {
    firstNonzeroDigit_ = -2;
    hashCode__ = 0;
    if (numBits < 0) {
      @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"numBits must be non-negative"] autorelease];
    }
    if (numBits == 0) {
      sign_ = 0;
      numberLength_ = 1;
      JavaMathBigInteger_set_digits_(self, [IOSIntArray arrayWithInts:(int[]){ 0 } count:1]);
    }
    else {
      sign_ = 1;
      numberLength_ = (numBits + 31) >> 5;
      JavaMathBigInteger_set_digits_(self, [IOSIntArray arrayWithLength:numberLength_]);
      for (int i = 0; i < numberLength_; i++) {
        (*IOSIntArray_GetRef(digits_, i)) = [((JavaUtilRandom *) nil_chk(rnd)) nextInt];
      }
      URShiftAssignInt(&(*IOSIntArray_GetRef(digits_, numberLength_ - 1)), (-numBits) & 31);
      [self cutOffLeadingZeroes];
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithInt:(int)bitLength
          withInt:(int)certainty
withJavaUtilRandom:(JavaUtilRandom *)rnd {
  if (self = [super init]) {
    firstNonzeroDigit_ = -2;
    hashCode__ = 0;
    if (bitLength < 2) {
      @throw [[[JavaLangArithmeticException alloc] initWithNSString:@"bitLength < 2"] autorelease];
    }
    JavaMathBigInteger *me = [JavaMathPrimality consBigIntegerWithInt:bitLength withInt:certainty withJavaUtilRandom:rnd];
    sign_ = ((JavaMathBigInteger *) nil_chk(me))->sign_;
    numberLength_ = me->numberLength_;
    JavaMathBigInteger_set_digits_(self, me->digits_);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithNSString:(NSString *)val {
  return JreMemDebugAdd([self initJavaMathBigIntegerWithNSString:val withInt:10]);
}

- (id)initJavaMathBigIntegerWithNSString:(NSString *)val
                                 withInt:(int)radix {
  if (self = [super init]) {
    firstNonzeroDigit_ = -2;
    hashCode__ = 0;
    if (val == nil) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    if ((radix < JavaLangCharacter_MIN_RADIX) || (radix > JavaLangCharacter_MAX_RADIX)) {
      @throw [[[JavaLangNumberFormatException alloc] initWithNSString:@"Radix out of range"] autorelease];
    }
    if ([((NSString *) nil_chk(val)) length] == 0) {
      @throw [[[JavaLangNumberFormatException alloc] initWithNSString:@"Zero length BigInteger"] autorelease];
    }
    [JavaMathBigInteger setFromStringWithJavaMathBigInteger:self withNSString:val withInt:radix];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithNSString:(NSString *)val
               withInt:(int)radix {
  return [self initJavaMathBigIntegerWithNSString:val withInt:radix];
}

- (id)initWithInt:(int)signum
    withByteArray:(IOSByteArray *)magnitude {
  if (self = [super init]) {
    firstNonzeroDigit_ = -2;
    hashCode__ = 0;
    if (magnitude == nil) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    if ((signum < -1) || (signum > 1)) {
      @throw [[[JavaLangNumberFormatException alloc] initWithNSString:@"Invalid signum value"] autorelease];
    }
    if (signum == 0) {
      {
        IOSByteArray *a__ = magnitude;
        char const *b__ = ((IOSByteArray *) nil_chk(a__))->buffer_;
        char const *e__ = b__ + a__->size_;
        while (b__ < e__) {
          char element = (*b__++);
          if (element != 0) {
            @throw [[[JavaLangNumberFormatException alloc] initWithNSString:@"signum-magnitude mismatch"] autorelease];
          }
        }
      }
    }
    if ((int) [((IOSByteArray *) nil_chk(magnitude)) count] == 0) {
      sign_ = 0;
      numberLength_ = 1;
      JavaMathBigInteger_set_digits_(self, [IOSIntArray arrayWithInts:(int[]){ 0 } count:1]);
    }
    else {
      sign_ = signum;
      [self putBytesPositiveToIntegersWithByteArray:magnitude];
      [self cutOffLeadingZeroes];
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithByteArray:(IOSByteArray *)val {
  if (self = [super init]) {
    firstNonzeroDigit_ = -2;
    hashCode__ = 0;
    if ((int) [((IOSByteArray *) nil_chk(val)) count] == 0) {
      @throw [[[JavaLangNumberFormatException alloc] initWithNSString:@"Zero length BigInteger"] autorelease];
    }
    if (IOSByteArray_Get(val, 0) < 0) {
      sign_ = -1;
      [self putBytesNegativeToIntegersWithByteArray:val];
    }
    else {
      sign_ = 1;
      [self putBytesPositiveToIntegersWithByteArray:val];
    }
    [self cutOffLeadingZeroes];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithInt:(int)sign
          withInt:(int)value {
  if (self = [super init]) {
    firstNonzeroDigit_ = -2;
    hashCode__ = 0;
    self->sign_ = sign;
    numberLength_ = 1;
    JavaMathBigInteger_set_digits_(self, [IOSIntArray arrayWithInts:(int[]){ value } count:1]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithInt:(int)sign
          withInt:(int)numberLength
     withIntArray:(IOSIntArray *)digits {
  if (self = [super init]) {
    firstNonzeroDigit_ = -2;
    hashCode__ = 0;
    self->sign_ = sign;
    self->numberLength_ = numberLength;
    JavaMathBigInteger_set_digits_(self, digits);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithInt:(int)sign
         withLong:(long long int)val {
  if (self = [super init]) {
    firstNonzeroDigit_ = -2;
    hashCode__ = 0;
    self->sign_ = sign;
    if ((val & (long long) 0xFFFFFFFF00000000LL) == 0) {
      numberLength_ = 1;
      JavaMathBigInteger_set_digits_(self, [IOSIntArray arrayWithInts:(int[]){ (int) val } count:1]);
    }
    else {
      numberLength_ = 2;
      JavaMathBigInteger_set_digits_(self, [IOSIntArray arrayWithInts:(int[]){ (int) val, (int) (val >> 32) } count:2]);
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithInt:(int)signum
     withIntArray:(IOSIntArray *)digits {
  if (self = [super init]) {
    firstNonzeroDigit_ = -2;
    hashCode__ = 0;
    if ((int) [((IOSIntArray *) nil_chk(digits)) count] == 0) {
      sign_ = 0;
      numberLength_ = 1;
      JavaMathBigInteger_set_digits_(self, [IOSIntArray arrayWithInts:(int[]){ 0 } count:1]);
    }
    else {
      sign_ = signum;
      numberLength_ = (int) [digits count];
      JavaMathBigInteger_set_digits_(self, digits);
      [self cutOffLeadingZeroes];
    }
    JreMemDebugAdd(self);
  }
  return self;
}

+ (JavaMathBigInteger *)valueOfWithLong:(long long int)val {
  if (val < 0) {
    if (val != -1) {
      return [[[JavaMathBigInteger alloc] initWithInt:-1 withLong:-val] autorelease];
    }
    return JavaMathBigInteger_MINUS_ONE_;
  }
  else if (val <= 10) {
    return IOSObjectArray_Get(nil_chk(JavaMathBigInteger_SMALL_VALUES_), (int) val);
  }
  else {
    return [[[JavaMathBigInteger alloc] initWithInt:1 withLong:val] autorelease];
  }
}

- (IOSByteArray *)toByteArray {
  if (self->sign_ == 0) {
    return [IOSByteArray arrayWithBytes:(char[]){ 0 } count:1];
  }
  JavaMathBigInteger *temp = self;
  int bitLen = [self bitLength];
  int iThis = [self getFirstNonzeroDigit];
  int bytesLen = (bitLen >> 3) + 1;
  IOSByteArray *bytes = [IOSByteArray arrayWithLength:bytesLen];
  int firstByteNumber = 0;
  int highBytes;
  int digitIndex = 0;
  int bytesInInteger = 4;
  int digit;
  int hB;
  if (bytesLen - (numberLength_ << 2) == 1) {
    (*IOSByteArray_GetRef(bytes, 0)) = (char) ((sign_ < 0) ? -1 : 0);
    highBytes = 4;
    firstByteNumber++;
  }
  else {
    hB = bytesLen & 3;
    highBytes = (hB == 0) ? 4 : hB;
  }
  digitIndex = iThis;
  bytesLen -= iThis << 2;
  if (sign_ < 0) {
    digit = -IOSIntArray_Get(nil_chk(temp->digits_), digitIndex);
    digitIndex++;
    if (digitIndex == numberLength_) {
      bytesInInteger = highBytes;
    }
    for (int i = 0; i < bytesInInteger; i++, digit >>= 8) {
      (*IOSByteArray_GetRef(bytes, --bytesLen)) = (char) digit;
    }
    while (bytesLen > firstByteNumber) {
      digit = ~IOSIntArray_Get(temp->digits_, digitIndex);
      digitIndex++;
      if (digitIndex == numberLength_) {
        bytesInInteger = highBytes;
      }
      for (int i = 0; i < bytesInInteger; i++, digit >>= 8) {
        (*IOSByteArray_GetRef(bytes, --bytesLen)) = (char) digit;
      }
    }
  }
  else {
    while (bytesLen > firstByteNumber) {
      digit = IOSIntArray_Get(nil_chk(temp->digits_), digitIndex);
      digitIndex++;
      if (digitIndex == numberLength_) {
        bytesInInteger = highBytes;
      }
      for (int i = 0; i < bytesInInteger; i++, digit >>= 8) {
        (*IOSByteArray_GetRef(bytes, --bytesLen)) = (char) digit;
      }
    }
  }
  return bytes;
}

+ (void)setFromStringWithJavaMathBigInteger:(JavaMathBigInteger *)bi
                               withNSString:(NSString *)val
                                    withInt:(int)radix {
  int sign;
  IOSIntArray *digits;
  int numberLength;
  int stringLength = [((NSString *) nil_chk(val)) length];
  int startChar;
  int endChar = stringLength;
  if ([val charAtWithInt:0] == '-') {
    sign = -1;
    startChar = 1;
    stringLength--;
  }
  else {
    sign = 1;
    startChar = 0;
  }
  int charsPerInt = IOSIntArray_Get(nil_chk([JavaMathConversion digitFitInInt]), radix);
  int bigRadixDigitsLength = stringLength / charsPerInt;
  int topChars = stringLength % charsPerInt;
  if (topChars != 0) {
    bigRadixDigitsLength++;
  }
  digits = [IOSIntArray arrayWithLength:bigRadixDigitsLength];
  int bigRadix = IOSIntArray_Get(nil_chk([JavaMathConversion bigRadices]), radix - 2);
  int digitIndex = 0;
  int substrEnd = startChar + ((topChars == 0) ? charsPerInt : topChars);
  int newDigit;
  for (int substrStart = startChar; substrStart < endChar; substrStart = substrEnd, substrEnd = substrStart + charsPerInt) {
    int bigRadixDigit = [JavaLangInteger parseIntWithNSString:[val substring:substrStart endIndex:substrEnd] withInt:radix];
    newDigit = [JavaMathMultiplication multiplyByIntWithIntArray:digits withInt:digitIndex withInt:bigRadix];
    newDigit += [JavaMathElementary inplaceAddWithIntArray:digits withInt:digitIndex withInt:bigRadixDigit];
    (*IOSIntArray_GetRef(digits, digitIndex++)) = newDigit;
  }
  numberLength = digitIndex;
  ((JavaMathBigInteger *) nil_chk(bi))->sign_ = sign;
  bi->numberLength_ = numberLength;
  JavaMathBigInteger_set_digits_(bi, digits);
  [bi cutOffLeadingZeroes];
}

- (JavaMathBigInteger *)abs {
  return ((sign_ < 0) ? [[[JavaMathBigInteger alloc] initWithInt:1 withInt:numberLength_ withIntArray:digits_] autorelease] : self);
}

- (JavaMathBigInteger *)negate {
  return ((sign_ == 0) ? self : [[[JavaMathBigInteger alloc] initWithInt:-sign_ withInt:numberLength_ withIntArray:digits_] autorelease]);
}

- (JavaMathBigInteger *)addWithJavaMathBigInteger:(JavaMathBigInteger *)val {
  return [JavaMathElementary addWithJavaMathBigInteger:self withJavaMathBigInteger:val];
}

- (JavaMathBigInteger *)subtractWithJavaMathBigInteger:(JavaMathBigInteger *)val {
  return [JavaMathElementary subtractWithJavaMathBigInteger:self withJavaMathBigInteger:val];
}

- (int)signum {
  return sign_;
}

- (JavaMathBigInteger *)shiftRightWithInt:(int)n {
  if ((n == 0) || (sign_ == 0)) {
    return self;
  }
  return ((n > 0) ? [JavaMathBitLevel shiftRightWithJavaMathBigInteger:self withInt:n] : [JavaMathBitLevel shiftLeftWithJavaMathBigInteger:self withInt:-n]);
}

- (JavaMathBigInteger *)shiftLeftWithInt:(int)n {
  if ((n == 0) || (sign_ == 0)) {
    return self;
  }
  return ((n > 0) ? [JavaMathBitLevel shiftLeftWithJavaMathBigInteger:self withInt:n] : [JavaMathBitLevel shiftRightWithJavaMathBigInteger:self withInt:-n]);
}

- (JavaMathBigInteger *)shiftLeftOneBit {
  return (sign_ == 0) ? self : [JavaMathBitLevel shiftLeftOneBitWithJavaMathBigInteger:self];
}

- (int)bitLength {
  return [JavaMathBitLevel bitLengthWithJavaMathBigInteger:self];
}

- (BOOL)testBitWithInt:(int)n {
  if (n == 0) {
    return ((IOSIntArray_Get(nil_chk(digits_), 0) & 1) != 0);
  }
  if (n < 0) {
    @throw [[[JavaLangArithmeticException alloc] initWithNSString:@"Negative bit address"] autorelease];
  }
  int intCount = n >> 5;
  if (intCount >= numberLength_) {
    return (sign_ < 0);
  }
  int digit = IOSIntArray_Get(nil_chk(digits_), intCount);
  n = (1 << (n & 31));
  if (sign_ < 0) {
    int firstNonZeroDigit = [self getFirstNonzeroDigit];
    if (intCount < firstNonZeroDigit) {
      return NO;
    }
    else if (firstNonZeroDigit == intCount) {
      digit = -digit;
    }
    else {
      digit = ~digit;
    }
  }
  return ((digit & n) != 0);
}

- (JavaMathBigInteger *)setBitWithInt:(int)n {
  if (![self testBitWithInt:n]) {
    return [JavaMathBitLevel flipBitWithJavaMathBigInteger:self withInt:n];
  }
  return self;
}

- (JavaMathBigInteger *)clearBitWithInt:(int)n {
  if ([self testBitWithInt:n]) {
    return [JavaMathBitLevel flipBitWithJavaMathBigInteger:self withInt:n];
  }
  return self;
}

- (JavaMathBigInteger *)flipBitWithInt:(int)n {
  if (n < 0) {
    @throw [[[JavaLangArithmeticException alloc] initWithNSString:@"Negative bit address"] autorelease];
  }
  return [JavaMathBitLevel flipBitWithJavaMathBigInteger:self withInt:n];
}

- (int)getLowestSetBit {
  if (sign_ == 0) {
    return -1;
  }
  int i = [self getFirstNonzeroDigit];
  return ((i << 5) + [JavaLangInteger numberOfTrailingZerosWithInt:IOSIntArray_Get(nil_chk(digits_), i)]);
}

- (int)bitCount {
  return [JavaMathBitLevel bitCountWithJavaMathBigInteger:self];
}

- (JavaMathBigInteger *)not__ {
  return [JavaMathLogical not__WithJavaMathBigInteger:self];
}

- (JavaMathBigInteger *)andWithJavaMathBigInteger:(JavaMathBigInteger *)val {
  return [JavaMathLogical andWithJavaMathBigInteger:self withJavaMathBigInteger:val];
}

- (JavaMathBigInteger *)orWithJavaMathBigInteger:(JavaMathBigInteger *)val {
  return [JavaMathLogical orWithJavaMathBigInteger:self withJavaMathBigInteger:val];
}

- (JavaMathBigInteger *)xorWithJavaMathBigInteger:(JavaMathBigInteger *)val {
  return [JavaMathLogical xorWithJavaMathBigInteger:self withJavaMathBigInteger:val];
}

- (JavaMathBigInteger *)andNotWithJavaMathBigInteger:(JavaMathBigInteger *)val {
  return [JavaMathLogical andNotWithJavaMathBigInteger:self withJavaMathBigInteger:val];
}

- (int)intValue {
  return (sign_ * IOSIntArray_Get(nil_chk(digits_), 0));
}

- (long long int)longLongValue {
  long long int value = (numberLength_ > 1) ? (((long long int) IOSIntArray_Get(nil_chk(digits_), 1)) << 32) | (IOSIntArray_Get(digits_, 0) & (long long) 0xFFFFFFFFLL) : (IOSIntArray_Get(nil_chk(digits_), 0) & (long long) 0xFFFFFFFFLL);
  return (sign_ * value);
}

- (float)floatValue {
  return (float) [self doubleValue];
}

- (double)doubleValue {
  return [JavaMathConversion bigInteger2DoubleWithJavaMathBigInteger:self];
}

- (int)compareToWithId:(JavaMathBigInteger *)val {
  if (val != nil && ![val isKindOfClass:[JavaMathBigInteger class]]) {
    @throw [[[JavaLangClassCastException alloc] init] autorelease];
  }
  if (sign_ > ((JavaMathBigInteger *) nil_chk(val))->sign_) {
    return JavaMathBigInteger_GREATER;
  }
  if (sign_ < val->sign_) {
    return JavaMathBigInteger_LESS;
  }
  if (numberLength_ > val->numberLength_) {
    return sign_;
  }
  if (numberLength_ < val->numberLength_) {
    return -val->sign_;
  }
  return (sign_ * [JavaMathElementary compareArraysWithIntArray:digits_ withIntArray:val->digits_ withInt:numberLength_]);
}

- (JavaMathBigInteger *)minWithJavaMathBigInteger:(JavaMathBigInteger *)val {
  return (([self compareToWithId:val] == JavaMathBigInteger_LESS) ? self : val);
}

- (JavaMathBigInteger *)maxWithJavaMathBigInteger:(JavaMathBigInteger *)val {
  return (([self compareToWithId:val] == JavaMathBigInteger_GREATER) ? self : val);
}

- (NSUInteger)hash {
  if (hashCode__ != 0) {
    return hashCode__;
  }
  for (int i = 0; i < (int) [((IOSIntArray *) nil_chk(digits_)) count]; i++) {
    hashCode__ = (hashCode__ * 33 + (IOSIntArray_Get(digits_, i) & (int) 0xffffffff));
  }
  hashCode__ = hashCode__ * sign_;
  return hashCode__;
}

- (BOOL)isEqual:(id)x {
  if (self == x) {
    return YES;
  }
  if ([x isKindOfClass:[JavaMathBigInteger class]]) {
    JavaMathBigInteger *x1 = (JavaMathBigInteger *) check_class_cast(x, [JavaMathBigInteger class]);
    return sign_ == ((JavaMathBigInteger *) nil_chk(x1))->sign_ && numberLength_ == x1->numberLength_ && [self equalsArraysWithIntArray:x1->digits_];
  }
  return NO;
}

- (BOOL)equalsArraysWithIntArray:(IOSIntArray *)b {
  int i;
  for (i = numberLength_ - 1; (i >= 0) && (IOSIntArray_Get(nil_chk(digits_), i) == IOSIntArray_Get(nil_chk(b), i)); i--) {
  }
  return i < 0;
}

- (NSString *)description {
  return [JavaMathConversion toDecimalScaledStringWithJavaMathBigInteger:self withInt:0];
}

- (NSString *)toStringWithInt:(int)radix {
  return [JavaMathConversion bigInteger2StringWithJavaMathBigInteger:self withInt:radix];
}

- (JavaMathBigInteger *)gcdWithJavaMathBigInteger:(JavaMathBigInteger *)val {
  JavaMathBigInteger *val1 = [self abs];
  JavaMathBigInteger *val2 = [((JavaMathBigInteger *) nil_chk(val)) abs];
  if ([((JavaMathBigInteger *) nil_chk(val1)) signum] == 0) {
    return val2;
  }
  else if ([((JavaMathBigInteger *) nil_chk(val2)) signum] == 0) {
    return val1;
  }
  if (((val1->numberLength_ == 1) || ((val1->numberLength_ == 2) && (IOSIntArray_Get(nil_chk(val1->digits_), 1) > 0))) && (((JavaMathBigInteger *) nil_chk(val2))->numberLength_ == 1 || (val2->numberLength_ == 2 && IOSIntArray_Get(nil_chk(val2->digits_), 1) > 0))) {
    return [JavaMathBigInteger valueOfWithLong:[JavaMathDivision gcdBinaryWithLong:[val1 longLongValue] withLong:[((JavaMathBigInteger *) nil_chk(val2)) longLongValue]]];
  }
  return [JavaMathDivision gcdBinaryWithJavaMathBigInteger:[val1 copy__] withJavaMathBigInteger:[((JavaMathBigInteger *) nil_chk(val2)) copy__]];
}

- (JavaMathBigInteger *)multiplyWithJavaMathBigInteger:(JavaMathBigInteger *)val {
  if (((JavaMathBigInteger *) nil_chk(val))->sign_ == 0) {
    return JavaMathBigInteger_ZERO_;
  }
  if (sign_ == 0) {
    return JavaMathBigInteger_ZERO_;
  }
  return [JavaMathMultiplication multiplyWithJavaMathBigInteger:self withJavaMathBigInteger:val];
}

- (JavaMathBigInteger *)powWithInt:(int)exp {
  if (exp < 0) {
    @throw [[[JavaLangArithmeticException alloc] initWithNSString:@"Negative exponent"] autorelease];
  }
  if (exp == 0) {
    return JavaMathBigInteger_ONE_;
  }
  else if (exp == 1 || [self isEqual:JavaMathBigInteger_ONE_] || [self isEqual:JavaMathBigInteger_ZERO_]) {
    return self;
  }
  if (![self testBitWithInt:0]) {
    int x = 1;
    while (![self testBitWithInt:x]) {
      x++;
    }
    return [((JavaMathBigInteger *) nil_chk([JavaMathBigInteger getPowerOfTwoWithInt:x * exp])) multiplyWithJavaMathBigInteger:[((JavaMathBigInteger *) nil_chk([self shiftRightWithInt:x])) powWithInt:exp]];
  }
  return [JavaMathMultiplication powWithJavaMathBigInteger:self withInt:exp];
}

- (IOSObjectArray *)divideAndRemainderWithJavaMathBigInteger:(JavaMathBigInteger *)divisor {
  int divisorSign = ((JavaMathBigInteger *) nil_chk(divisor))->sign_;
  if (divisorSign == 0) {
    @throw [[[JavaLangArithmeticException alloc] initWithNSString:@"BigInteger divide by zero"] autorelease];
  }
  int divisorLen = divisor->numberLength_;
  IOSIntArray *divisorDigits = divisor->digits_;
  if (divisorLen == 1) {
    return [JavaMathDivision divideAndRemainderByIntegerWithJavaMathBigInteger:self withInt:IOSIntArray_Get(nil_chk(divisorDigits), 0) withInt:divisorSign];
  }
  IOSIntArray *thisDigits = digits_;
  int thisLen = numberLength_;
  int cmp = (thisLen != divisorLen) ? ((thisLen > divisorLen) ? 1 : -1) : [JavaMathElementary compareArraysWithIntArray:thisDigits withIntArray:divisorDigits withInt:thisLen];
  if (cmp < 0) {
    return [IOSObjectArray arrayWithObjects:(id[]){ JavaMathBigInteger_ZERO_, self } count:2 type:[IOSClass classWithClass:[JavaMathBigInteger class]]];
  }
  int thisSign = sign_;
  int quotientLength = thisLen - divisorLen + 1;
  int remainderLength = divisorLen;
  int quotientSign = ((thisSign == divisorSign) ? 1 : -1);
  IOSIntArray *quotientDigits = [IOSIntArray arrayWithLength:quotientLength];
  IOSIntArray *remainderDigits = [JavaMathDivision divideWithIntArray:quotientDigits withInt:quotientLength withIntArray:thisDigits withInt:thisLen withIntArray:divisorDigits withInt:divisorLen];
  JavaMathBigInteger *result0 = [[[JavaMathBigInteger alloc] initWithInt:quotientSign withInt:quotientLength withIntArray:quotientDigits] autorelease];
  JavaMathBigInteger *result1 = [[[JavaMathBigInteger alloc] initWithInt:thisSign withInt:remainderLength withIntArray:remainderDigits] autorelease];
  [result0 cutOffLeadingZeroes];
  [result1 cutOffLeadingZeroes];
  return [IOSObjectArray arrayWithObjects:(id[]){ result0, result1 } count:2 type:[IOSClass classWithClass:[JavaMathBigInteger class]]];
}

- (JavaMathBigInteger *)divideWithJavaMathBigInteger:(JavaMathBigInteger *)divisor {
  if (((JavaMathBigInteger *) nil_chk(divisor))->sign_ == 0) {
    @throw [[[JavaLangArithmeticException alloc] initWithNSString:@"BigInteger divide by zero"] autorelease];
  }
  int divisorSign = divisor->sign_;
  if ([divisor isOne]) {
    return ((divisor->sign_ > 0) ? self : [self negate]);
  }
  int thisSign = sign_;
  int thisLen = numberLength_;
  int divisorLen = divisor->numberLength_;
  if (thisLen + divisorLen == 2) {
    long long int val = (IOSIntArray_Get(nil_chk(digits_), 0) & (long long) 0xFFFFFFFFLL) / (IOSIntArray_Get(divisor->digits_, 0) & (long long) 0xFFFFFFFFLL);
    if (thisSign != divisorSign) {
      val = -val;
    }
    return [JavaMathBigInteger valueOfWithLong:val];
  }
  int cmp = ((thisLen != divisorLen) ? ((thisLen > divisorLen) ? 1 : -1) : [JavaMathElementary compareArraysWithIntArray:digits_ withIntArray:divisor->digits_ withInt:thisLen]);
  if (cmp == JavaMathBigInteger_EQUALS) {
    return ((thisSign == divisorSign) ? JavaMathBigInteger_ONE_ : JavaMathBigInteger_MINUS_ONE_);
  }
  if (cmp == JavaMathBigInteger_LESS) {
    return JavaMathBigInteger_ZERO_;
  }
  int resLength = thisLen - divisorLen + 1;
  IOSIntArray *resDigits = [IOSIntArray arrayWithLength:resLength];
  int resSign = ((thisSign == divisorSign) ? 1 : -1);
  if (divisorLen == 1) {
    [JavaMathDivision divideArrayByIntWithIntArray:resDigits withIntArray:digits_ withInt:thisLen withInt:IOSIntArray_Get(nil_chk(divisor->digits_), 0)];
  }
  else {
    [JavaMathDivision divideWithIntArray:resDigits withInt:resLength withIntArray:digits_ withInt:thisLen withIntArray:divisor->digits_ withInt:divisorLen];
  }
  JavaMathBigInteger *result = [[[JavaMathBigInteger alloc] initWithInt:resSign withInt:resLength withIntArray:resDigits] autorelease];
  [result cutOffLeadingZeroes];
  return result;
}

- (JavaMathBigInteger *)remainderWithJavaMathBigInteger:(JavaMathBigInteger *)divisor {
  if (((JavaMathBigInteger *) nil_chk(divisor))->sign_ == 0) {
    @throw [[[JavaLangArithmeticException alloc] initWithNSString:@"BigInteger divide by zero"] autorelease];
  }
  int thisLen = numberLength_;
  int divisorLen = divisor->numberLength_;
  if (((thisLen != divisorLen) ? ((thisLen > divisorLen) ? 1 : -1) : [JavaMathElementary compareArraysWithIntArray:digits_ withIntArray:divisor->digits_ withInt:thisLen]) == JavaMathBigInteger_LESS) {
    return self;
  }
  int resLength = divisorLen;
  IOSIntArray *resDigits = [IOSIntArray arrayWithLength:resLength];
  if (resLength == 1) {
    (*IOSIntArray_GetRef(resDigits, 0)) = [JavaMathDivision remainderArrayByIntWithIntArray:digits_ withInt:thisLen withInt:IOSIntArray_Get(nil_chk(divisor->digits_), 0)];
  }
  else {
    int qLen = thisLen - divisorLen + 1;
    resDigits = [JavaMathDivision divideWithIntArray:nil withInt:qLen withIntArray:digits_ withInt:thisLen withIntArray:divisor->digits_ withInt:divisorLen];
  }
  JavaMathBigInteger *result = [[[JavaMathBigInteger alloc] initWithInt:sign_ withInt:resLength withIntArray:resDigits] autorelease];
  [result cutOffLeadingZeroes];
  return result;
}

- (JavaMathBigInteger *)modInverseWithJavaMathBigInteger:(JavaMathBigInteger *)m {
  if (((JavaMathBigInteger *) nil_chk(m))->sign_ <= 0) {
    @throw [[[JavaLangArithmeticException alloc] initWithNSString:@"BigInteger: modulus not positive"] autorelease];
  }
  if (!([self testBitWithInt:0] || [m testBitWithInt:0])) {
    @throw [[[JavaLangArithmeticException alloc] initWithNSString:@"BigInteger not invertible."] autorelease];
  }
  if ([m isOne]) {
    return JavaMathBigInteger_ZERO_;
  }
  JavaMathBigInteger *res = [JavaMathDivision modInverseMontgomeryWithJavaMathBigInteger:[((JavaMathBigInteger *) nil_chk([self abs])) modWithJavaMathBigInteger:m] withJavaMathBigInteger:m];
  if (((JavaMathBigInteger *) nil_chk(res))->sign_ == 0) {
    @throw [[[JavaLangArithmeticException alloc] initWithNSString:@"BigInteger not invertible."] autorelease];
  }
  res = ((sign_ < 0) ? [m subtractWithJavaMathBigInteger:res] : res);
  return res;
}

- (JavaMathBigInteger *)modPowWithJavaMathBigInteger:(JavaMathBigInteger *)exponent
                              withJavaMathBigInteger:(JavaMathBigInteger *)m {
  if (((JavaMathBigInteger *) nil_chk(m))->sign_ <= 0) {
    @throw [[[JavaLangArithmeticException alloc] initWithNSString:@"BigInteger: modulus not positive"] autorelease];
  }
  JavaMathBigInteger *base = self;
  if ([m isOne] | (((JavaMathBigInteger *) nil_chk(exponent))->sign_ > 0 & base->sign_ == 0)) {
    return JavaMathBigInteger_ZERO_;
  }
  if (exponent->sign_ == 0) {
    return [((JavaMathBigInteger *) nil_chk(JavaMathBigInteger_ONE_)) modWithJavaMathBigInteger:m];
  }
  if (exponent->sign_ < 0) {
    base = [self modInverseWithJavaMathBigInteger:m];
    exponent = [exponent negate];
  }
  JavaMathBigInteger *res = ([m testBitWithInt:0]) ? [JavaMathDivision oddModPowWithJavaMathBigInteger:[((JavaMathBigInteger *) nil_chk(base)) abs] withJavaMathBigInteger:exponent withJavaMathBigInteger:m] : [JavaMathDivision evenModPowWithJavaMathBigInteger:[((JavaMathBigInteger *) nil_chk(base)) abs] withJavaMathBigInteger:exponent withJavaMathBigInteger:m];
  if ((((JavaMathBigInteger *) nil_chk(base))->sign_ < 0) && [((JavaMathBigInteger *) nil_chk(exponent)) testBitWithInt:0]) {
    res = [((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk([m subtractWithJavaMathBigInteger:JavaMathBigInteger_ONE_])) multiplyWithJavaMathBigInteger:res])) modWithJavaMathBigInteger:m];
  }
  return res;
}

- (JavaMathBigInteger *)modWithJavaMathBigInteger:(JavaMathBigInteger *)m {
  if (((JavaMathBigInteger *) nil_chk(m))->sign_ <= 0) {
    @throw [[[JavaLangArithmeticException alloc] initWithNSString:@"BigInteger: modulus not positive"] autorelease];
  }
  JavaMathBigInteger *rem = [self remainderWithJavaMathBigInteger:m];
  return ((((JavaMathBigInteger *) nil_chk(rem))->sign_ < 0) ? [rem addWithJavaMathBigInteger:m] : rem);
}

- (BOOL)isProbablePrimeWithInt:(int)certainty {
  return [JavaMathPrimality isProbablePrimeWithJavaMathBigInteger:[self abs] withInt:certainty];
}

- (JavaMathBigInteger *)nextProbablePrime {
  if (sign_ < 0) {
    @throw [[[JavaLangArithmeticException alloc] initWithNSString:[NSString stringWithFormat:@"start < 0: %@", [self description]]] autorelease];
  }
  return [JavaMathPrimality nextProbablePrimeWithJavaMathBigInteger:self];
}

+ (JavaMathBigInteger *)probablePrimeWithInt:(int)bitLength
                          withJavaUtilRandom:(JavaUtilRandom *)rnd {
  return [[[JavaMathBigInteger alloc] initWithInt:bitLength withInt:100 withJavaUtilRandom:rnd] autorelease];
}

- (void)cutOffLeadingZeroes {
  while ((numberLength_ > 0) && (IOSIntArray_Get(nil_chk(digits_), --numberLength_) == 0)) {
  }
  if (IOSIntArray_Get(nil_chk(digits_), numberLength_++) == 0) {
    sign_ = 0;
  }
}

- (BOOL)isOne {
  return ((numberLength_ == 1) && (IOSIntArray_Get(nil_chk(digits_), 0) == 1));
}

- (void)putBytesPositiveToIntegersWithByteArray:(IOSByteArray *)byteValues {
  int bytesLen = (int) [((IOSByteArray *) nil_chk(byteValues)) count];
  int highBytes = bytesLen & 3;
  numberLength_ = (bytesLen >> 2) + ((highBytes == 0) ? 0 : 1);
  JavaMathBigInteger_set_digits_(self, [IOSIntArray arrayWithLength:numberLength_]);
  int i = 0;
  while (bytesLen > highBytes) {
    int tmp = (IOSByteArray_Get(byteValues, --bytesLen) & (int) 0xFF);
    tmp |= (IOSByteArray_Get(byteValues, --bytesLen) & (int) 0xFF) << 8;
    tmp |= (IOSByteArray_Get(byteValues, --bytesLen) & (int) 0xFF) << 16;
    tmp |= (IOSByteArray_Get(byteValues, --bytesLen) & (int) 0xFF) << 24;
    (*IOSIntArray_GetRef(digits_, i++)) = tmp;
  }
  for (int j = 0; j < bytesLen; j++) {
    (*IOSIntArray_GetRef(digits_, i)) = (IOSIntArray_Get(digits_, i) << 8) | (IOSByteArray_Get(byteValues, j) & (int) 0xFF);
  }
}

- (void)putBytesNegativeToIntegersWithByteArray:(IOSByteArray *)byteValues {
  int bytesLen = (int) [((IOSByteArray *) nil_chk(byteValues)) count];
  int highBytes = bytesLen & 3;
  numberLength_ = (bytesLen >> 2) + ((highBytes == 0) ? 0 : 1);
  JavaMathBigInteger_set_digits_(self, [IOSIntArray arrayWithLength:numberLength_]);
  int i = 0;
  (*IOSIntArray_GetRef(digits_, numberLength_ - 1)) = -1;
  while (bytesLen > highBytes) {
    int tmp = (IOSByteArray_Get(byteValues, --bytesLen) & (int) 0xFF);
    tmp |= (IOSByteArray_Get(byteValues, --bytesLen) & (int) 0xFF) << 8;
    tmp |= (IOSByteArray_Get(byteValues, --bytesLen) & (int) 0xFF) << 16;
    tmp |= (IOSByteArray_Get(byteValues, --bytesLen) & (int) 0xFF) << 24;
    (*IOSIntArray_GetRef(digits_, i)) = tmp;
    if (IOSIntArray_Get(digits_, i) != 0) {
      (*IOSIntArray_GetRef(digits_, i)) = -IOSIntArray_Get(digits_, i);
      firstNonzeroDigit_ = i;
      i++;
      while (bytesLen > highBytes) {
        tmp = (IOSByteArray_Get(byteValues, --bytesLen) & (int) 0xFF);
        tmp |= (IOSByteArray_Get(byteValues, --bytesLen) & (int) 0xFF) << 8;
        tmp |= (IOSByteArray_Get(byteValues, --bytesLen) & (int) 0xFF) << 16;
        tmp |= (IOSByteArray_Get(byteValues, --bytesLen) & (int) 0xFF) << 24;
        (*IOSIntArray_GetRef(digits_, i)) = ~tmp;
        i++;
      }
      break;
    }
    i++;
  }
  if (highBytes != 0) {
    if (firstNonzeroDigit_ != -2) {
      for (int j = 0; j < bytesLen; j++) {
        (*IOSIntArray_GetRef(digits_, i)) = (IOSIntArray_Get(digits_, i) << 8) | (IOSByteArray_Get(byteValues, j) & (int) 0xFF);
      }
      (*IOSIntArray_GetRef(digits_, i)) = ~IOSIntArray_Get(digits_, i);
    }
    else {
      for (int j = 0; j < bytesLen; j++) {
        (*IOSIntArray_GetRef(digits_, i)) = (IOSIntArray_Get(digits_, i) << 8) | (IOSByteArray_Get(byteValues, j) & (int) 0xFF);
      }
      (*IOSIntArray_GetRef(digits_, i)) = -IOSIntArray_Get(digits_, i);
    }
  }
}

- (int)getFirstNonzeroDigit {
  if (firstNonzeroDigit_ == -2) {
    int i;
    if (self->sign_ == 0) {
      i = -1;
    }
    else {
      for (i = 0; IOSIntArray_Get(nil_chk(digits_), i) == 0; i++) {
      }
    }
    firstNonzeroDigit_ = i;
  }
  return firstNonzeroDigit_;
}

- (JavaMathBigInteger *)copy__ {
  IOSIntArray *copyDigits = [IOSIntArray arrayWithLength:numberLength_];
  [JavaLangSystem arraycopyWithId:digits_ withInt:0 withId:copyDigits withInt:0 withInt:numberLength_];
  return [[[JavaMathBigInteger alloc] initWithInt:sign_ withInt:numberLength_ withIntArray:copyDigits] autorelease];
}

- (void)unCache {
  firstNonzeroDigit_ = -2;
}

+ (JavaMathBigInteger *)getPowerOfTwoWithInt:(int)exp {
  if (exp < (int) [((IOSObjectArray *) nil_chk(JavaMathBigInteger_TWO_POWS_)) count]) {
    return IOSObjectArray_Get(JavaMathBigInteger_TWO_POWS_, exp);
  }
  int intCount = exp >> 5;
  int bitN = exp & 31;
  IOSIntArray *resDigits = [IOSIntArray arrayWithLength:intCount + 1];
  (*IOSIntArray_GetRef(resDigits, intCount)) = 1 << bitN;
  return [[[JavaMathBigInteger alloc] initWithInt:1 withInt:intCount + 1 withIntArray:resDigits] autorelease];
}

+ (void)initialize {
  if (self == [JavaMathBigInteger class]) {
    JreOperatorRetainedAssign(&JavaMathBigInteger_ZERO_, nil, [[[JavaMathBigInteger alloc] initWithInt:0 withInt:0] autorelease]);
    JreOperatorRetainedAssign(&JavaMathBigInteger_ONE_, nil, [[[JavaMathBigInteger alloc] initWithInt:1 withInt:1] autorelease]);
    JreOperatorRetainedAssign(&JavaMathBigInteger_TEN_, nil, [[[JavaMathBigInteger alloc] initWithInt:1 withInt:10] autorelease]);
    JreOperatorRetainedAssign(&JavaMathBigInteger_MINUS_ONE_, nil, [[[JavaMathBigInteger alloc] initWithInt:-1 withInt:1] autorelease]);
    JreOperatorRetainedAssign(&JavaMathBigInteger_SMALL_VALUES_, nil, [IOSObjectArray arrayWithObjects:(id[]){ JavaMathBigInteger_ZERO_, JavaMathBigInteger_ONE_, [[[JavaMathBigInteger alloc] initWithInt:1 withInt:2] autorelease], [[[JavaMathBigInteger alloc] initWithInt:1 withInt:3] autorelease], [[[JavaMathBigInteger alloc] initWithInt:1 withInt:4] autorelease], [[[JavaMathBigInteger alloc] initWithInt:1 withInt:5] autorelease], [[[JavaMathBigInteger alloc] initWithInt:1 withInt:6] autorelease], [[[JavaMathBigInteger alloc] initWithInt:1 withInt:7] autorelease], [[[JavaMathBigInteger alloc] initWithInt:1 withInt:8] autorelease], [[[JavaMathBigInteger alloc] initWithInt:1 withInt:9] autorelease], JavaMathBigInteger_TEN_ } count:11 type:[IOSClass classWithClass:[JavaMathBigInteger class]]]);
    {
      JreOperatorRetainedAssign(&JavaMathBigInteger_TWO_POWS_, nil, [IOSObjectArray arrayWithLength:32 type:[IOSClass classWithClass:[JavaMathBigInteger class]]]);
      for (int i = 0; i < (int) [JavaMathBigInteger_TWO_POWS_ count]; i++) {
        IOSObjectArray_Set(JavaMathBigInteger_TWO_POWS_, i, [JavaMathBigInteger valueOfWithLong:1LL << i]);
      }
    }
  }
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaMathBigInteger_set_magnitude_(self, nil);
  JavaMathBigInteger_set_digits_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaMathBigInteger *)other {
  [super copyAllFieldsTo:other];
  JavaMathBigInteger_set_digits_(other, digits_);
  other->firstNonzeroDigit_ = firstNonzeroDigit_;
  other->hashCode__ = hashCode__;
  JavaMathBigInteger_set_magnitude_(other, magnitude_);
  other->numberLength_ = numberLength_;
  other->sign_ = sign_;
  other->signum__ = signum__;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:digits_ name:@"digits"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:magnitude_ name:@"magnitude"]];
  return result;
}

@end
