//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/io/BufferedReader.java
//
//  Created by retechretech on 13-9-25.
//

#include "IOSCharArray.h"
#include "IOSClass.h"
#include "java/io/BufferedReader.h"
#include "java/io/IOException.h"
#include "java/io/Reader.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"

@implementation JavaIoBufferedReader

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithJavaIoReader:(JavaIoReader *)inArg {
  if (self = [super initWithId:inArg]) {
    mark__ = -1;
    markLimit_ = -1;
    JavaIoBufferedReader_set_in_(self, inArg);
    JavaIoBufferedReader_set_buf_(self, [IOSCharArray arrayWithLength:8192]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaIoReader:(JavaIoReader *)inArg
                   withInt:(int)size {
  if (self = [super initWithId:inArg]) {
    mark__ = -1;
    markLimit_ = -1;
    if (size <= 0) {
      @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"size must be > 0"] autorelease];
    }
    JavaIoBufferedReader_set_in_(self, inArg);
    JavaIoBufferedReader_set_buf_(self, [IOSCharArray arrayWithLength:size]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)close {
  @synchronized (lock_) {
    if (![self isClosed]) {
      [((JavaIoReader *) nil_chk(in_)) close];
      JavaIoBufferedReader_set_buf_(self, nil);
    }
  }
}

+ (IOSObjectArray *)__exceptions_close {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)fillBuf {
  if (mark__ == -1 || (pos_ - mark__ >= markLimit_)) {
    int result = [((JavaIoReader *) nil_chk(in_)) readWithCharArray:buf_ withInt:0 withInt:(int) [((IOSCharArray *) nil_chk(buf_)) count]];
    if (result > 0) {
      mark__ = -1;
      pos_ = 0;
      end_ = result;
    }
    return result;
  }
  if (mark__ == 0 && markLimit_ > (int) [((IOSCharArray *) nil_chk(buf_)) count]) {
    int newLength = (int) [buf_ count] * 2;
    if (newLength > markLimit_) {
      newLength = markLimit_;
    }
    IOSCharArray *newbuf = [IOSCharArray arrayWithLength:newLength];
    [JavaLangSystem arraycopyWithId:buf_ withInt:0 withId:newbuf withInt:0 withInt:(int) [buf_ count]];
    JavaIoBufferedReader_set_buf_(self, newbuf);
  }
  else if (mark__ > 0) {
    [JavaLangSystem arraycopyWithId:buf_ withInt:mark__ withId:buf_ withInt:0 withInt:(int) [((IOSCharArray *) nil_chk(buf_)) count] - mark__];
    pos_ -= mark__;
    end_ -= mark__;
    mark__ = 0;
  }
  int count = [((JavaIoReader *) nil_chk(in_)) readWithCharArray:buf_ withInt:pos_ withInt:(int) [((IOSCharArray *) nil_chk(buf_)) count] - pos_];
  if (count != -1) {
    end_ += count;
  }
  return count;
}

+ (IOSObjectArray *)__exceptions_fillBuf {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (BOOL)isClosed {
  return buf_ == nil;
}

- (void)markWithInt:(int)markLimit {
  if (markLimit < 0) {
    @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
  }
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"BufferedReader is closed"] autorelease];
    }
    self->markLimit_ = markLimit;
    mark__ = pos_;
  }
}

+ (IOSObjectArray *)__exceptions_markWithInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (BOOL)markSupported {
  return YES;
}

- (int)read {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"BufferedReader is closed"] autorelease];
    }
    if (pos_ < end_ || [self fillBuf] != -1) {
      return IOSCharArray_Get(nil_chk(buf_), pos_++);
    }
    return -1;
  }
}

+ (IOSObjectArray *)__exceptions_read {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)readWithCharArray:(IOSCharArray *)buffer
                 withInt:(int)offset
                 withInt:(int)length {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"BufferedReader is closed"] autorelease];
    }
    if (offset < 0 || offset > (int) [((IOSCharArray *) nil_chk(buffer)) count] - length || length < 0) {
      @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
    }
    int outstanding = length;
    while (outstanding > 0) {
      int available = end_ - pos_;
      if (available > 0) {
        int count = available >= outstanding ? outstanding : available;
        [JavaLangSystem arraycopyWithId:buf_ withInt:pos_ withId:buffer withInt:offset withInt:count];
        pos_ += count;
        offset += count;
        outstanding -= count;
      }
      if (outstanding == 0 || (outstanding < length && ![((JavaIoReader *) nil_chk(in_)) ready])) {
        break;
      }
      if ((mark__ == -1 || (pos_ - mark__ >= markLimit_)) && outstanding >= (int) [((IOSCharArray *) nil_chk(buf_)) count]) {
        int count = [((JavaIoReader *) nil_chk(in_)) readWithCharArray:buffer withInt:offset withInt:outstanding];
        if (count > 0) {
          offset += count;
          outstanding -= count;
          mark__ = -1;
        }
        break;
      }
      if ([self fillBuf] == -1) {
        break;
      }
    }
    int count = length - outstanding;
    return (count > 0 || count == length) ? count : -1;
  }
}

+ (IOSObjectArray *)__exceptions_readWithCharArray_withInt_withInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)chompNewline {
  if ((pos_ != end_ || [self fillBuf] != -1) && IOSCharArray_Get(nil_chk(buf_), pos_) == 0x000a) {
    pos_++;
  }
}

+ (IOSObjectArray *)__exceptions_chompNewline {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (NSString *)readLine {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"BufferedReader is closed"] autorelease];
    }
    if (pos_ == end_ && [self fillBuf] == -1) {
      return nil;
    }
    for (int charPos = pos_; charPos < end_; charPos++) {
      unichar ch = IOSCharArray_Get(nil_chk(buf_), charPos);
      if (ch > 0x000d) {
        continue;
      }
      if (ch == 0x000a) {
        NSString *res = [NSString stringWithCharacters:buf_ offset:pos_ length:charPos - pos_];
        pos_ = charPos + 1;
        return res;
      }
      else if (ch == 0x000d) {
        NSString *res = [NSString stringWithCharacters:buf_ offset:pos_ length:charPos - pos_];
        pos_ = charPos + 1;
        if (((pos_ < end_) || ([self fillBuf] != -1)) && (IOSCharArray_Get(buf_, pos_) == 0x000a)) {
          pos_++;
        }
        return res;
      }
    }
    unichar eol = 0x0000;
    JavaLangStringBuilder *result = [[[JavaLangStringBuilder alloc] initWithInt:80] autorelease];
    [result appendWithCharArray:buf_ withInt:pos_ withInt:end_ - pos_];
    while (YES) {
      pos_ = end_;
      if (eol == 0x000a) {
        return [result description];
      }
      if ([self fillBuf] == -1) {
        return [result sequenceLength] > 0 || eol != 0x0000 ? [result description] : nil;
      }
      for (int charPos = pos_; charPos < end_; charPos++) {
        unichar c = IOSCharArray_Get(nil_chk(buf_), charPos);
        if (eol == 0x0000) {
          if ((c == 0x000a || c == 0x000d)) {
            eol = c;
          }
        }
        else if (eol == 0x000d && c == 0x000a) {
          if (charPos > pos_) {
            [result appendWithCharArray:buf_ withInt:pos_ withInt:charPos - pos_ - 1];
          }
          pos_ = charPos + 1;
          return [result description];
        }
        else {
          if (charPos > pos_) {
            [result appendWithCharArray:buf_ withInt:pos_ withInt:charPos - pos_ - 1];
          }
          pos_ = charPos;
          return [result description];
        }
      }
      if (eol == 0x0000) {
        [result appendWithCharArray:buf_ withInt:pos_ withInt:end_ - pos_];
      }
      else {
        [result appendWithCharArray:buf_ withInt:pos_ withInt:end_ - pos_ - 1];
      }
    }
  }
}

+ (IOSObjectArray *)__exceptions_readLine {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (BOOL)ready {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"BufferedReader is closed"] autorelease];
    }
    return ((end_ - pos_) > 0) || [((JavaIoReader *) nil_chk(in_)) ready];
  }
}

+ (IOSObjectArray *)__exceptions_ready {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)reset {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"BufferedReader is closed"] autorelease];
    }
    if (mark__ == -1) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"Invalid Mark."] autorelease];
    }
    pos_ = mark__;
  }
}

+ (IOSObjectArray *)__exceptions_reset {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (long long int)skipWithLong:(long long int)amount {
  if (amount < 0) {
    @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
  }
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"BufferedReader is closed"] autorelease];
    }
    if (amount < 1) {
      return 0;
    }
    if (end_ - pos_ >= amount) {
      pos_ += amount;
      return amount;
    }
    long long int read = end_ - pos_;
    pos_ = end_;
    while (read < amount) {
      if ([self fillBuf] == -1) {
        return read;
      }
      if (end_ - pos_ >= amount - read) {
        pos_ += amount - read;
        return amount;
      }
      read += (end_ - pos_);
      pos_ = end_;
    }
    return amount;
  }
}

+ (IOSObjectArray *)__exceptions_skipWithLong_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaIoBufferedReader_set_buf_(self, nil);
  JavaIoBufferedReader_set_in_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaIoBufferedReader *)other {
  [super copyAllFieldsTo:other];
  JavaIoBufferedReader_set_buf_(other, buf_);
  other->end_ = end_;
  JavaIoBufferedReader_set_in_(other, in_);
  other->mark__ = mark__;
  other->markLimit_ = markLimit_;
  other->pos_ = pos_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:in_ name:@"in"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:buf_ name:@"buf"]];
  return result;
}

@end
