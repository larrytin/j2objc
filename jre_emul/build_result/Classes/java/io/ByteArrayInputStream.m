//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/io/ByteArrayInputStream.java
//
//  Created by retechretech on 13-9-25.
//

#include "IOSByteArray.h"
#include "IOSClass.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/IOException.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/System.h"

@implementation JavaIoByteArrayInputStream

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithByteArray:(IOSByteArray *)buf {
  if (self = [super init]) {
    self->mark__ = 0;
    JavaIoByteArrayInputStream_set_buf_(self, buf);
    self->count_ = (int) [((IOSByteArray *) nil_chk(buf)) count];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithByteArray:(IOSByteArray *)buf
                withInt:(int)offset
                withInt:(int)length {
  if (self = [super init]) {
    JavaIoByteArrayInputStream_set_buf_(self, buf);
    pos_ = offset;
    mark__ = offset;
    count_ = offset + length > (int) [((IOSByteArray *) nil_chk(buf)) count] ? (int) [buf count] : offset + length;
    JreMemDebugAdd(self);
  }
  return self;
}

- (int)available {
  @synchronized(self) {
    {
      return count_ - pos_;
    }
  }
}

- (void)close {
}

+ (IOSObjectArray *)__exceptions_close {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)markWithInt:(int)readlimit {
  @synchronized(self) {
    {
      mark__ = pos_;
    }
  }
}

- (BOOL)markSupported {
  return YES;
}

- (int)read {
  @synchronized(self) {
    {
      return pos_ < count_ ? IOSByteArray_Get(nil_chk(buf_), pos_++) & (int) 0xFF : -1;
    }
  }
}

- (int)readWithByteArray:(IOSByteArray *)b
                 withInt:(int)offset
                 withInt:(int)length {
  @synchronized(self) {
    {
      if (b == nil) {
        @throw [[[JavaLangNullPointerException alloc] init] autorelease];
      }
      if (offset < 0 || offset > (int) [((IOSByteArray *) nil_chk(b)) count] || length < 0 || length > (int) [b count] - offset) {
        @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
      }
      if (self->pos_ >= self->count_) {
        return -1;
      }
      if (length == 0) {
        return 0;
      }
      int copylen = self->count_ - pos_ < length ? self->count_ - pos_ : length;
      [JavaLangSystem arraycopyWithId:buf_ withInt:pos_ withId:b withInt:offset withInt:copylen];
      pos_ += copylen;
      return copylen;
    }
  }
}

- (void)reset {
  @synchronized(self) {
    {
      pos_ = mark__;
    }
  }
}

- (long long int)skipWithLong:(long long int)n {
  @synchronized(self) {
    {
      if (n <= 0) {
        return 0;
      }
      int temp = pos_;
      pos_ = self->count_ - pos_ < n ? self->count_ : (int) (pos_ + n);
      return pos_ - temp;
    }
  }
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaIoByteArrayInputStream_set_buf_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaIoByteArrayInputStream *)other {
  [super copyAllFieldsTo:other];
  JavaIoByteArrayInputStream_set_buf_(other, buf_);
  other->count_ = count_;
  other->mark__ = mark__;
  other->pos_ = pos_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:buf_ name:@"buf"]];
  return result;
}

@end
