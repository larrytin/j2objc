//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//
//  Created by Larry Tin <dev@goodow.com>
//

#include "IOSByteArray.h"
#include "IOSCharArray.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "java/io/File.h"
#include "java/io/FileFilter.h"
#include "java/io/FilenameFilter.h"
#include "java/io/IOException.h"
#include "java/lang/AssertionError.h"
#include "java/lang/ClassCastException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/InternalError.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/util/ArrayList.h"
#include "java/util/List.h"
#include "java/util/Locale.h"
#include "java/util/Random.h"
#import <sys/utsname.h>

@implementation JavaIoFile

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaIoFile_EMPTY_STRING_ name:@"JavaIoFile_EMPTY_STRING_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaIoFile_separator_ name:@"JavaIoFile_separator_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaIoFile_pathSeparator_ name:@"JavaIoFile_pathSeparator_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaIoFile_tempFileLocker_ name:@"JavaIoFile_tempFileLocker_"]];
  return result;
}

static NSString * JavaIoFile_EMPTY_STRING_ = @"";
static NSString * JavaIoFile_separator_ = @"/";
static NSString * JavaIoFile_pathSeparator_ = @":";
static int JavaIoFile_counter_;
static int JavaIoFile_counterBase_;
static JavaIoFile_TempFileLocker * JavaIoFile_tempFileLocker_;
static BOOL JavaIoFile_caseSensitive_;

+ (NSString *)EMPTY_STRING {
  return JavaIoFile_EMPTY_STRING_;
}

+ (unichar)separatorChar {
  return JavaIoFile_separatorChar;
}

+ (NSString *)separator {
  return JavaIoFile_separator_;
}

+ (unichar)pathSeparatorChar {
  return JavaIoFile_pathSeparatorChar;
}

+ (NSString *)pathSeparator {
  return JavaIoFile_pathSeparator_;
}

+ (int)counter {
  return JavaIoFile_counter_;
}

+ (int *)counterRef {
  return &JavaIoFile_counter_;
}

+ (int)counterBase {
  return JavaIoFile_counterBase_;
}

+ (int *)counterBaseRef {
  return &JavaIoFile_counterBase_;
}

+ (JavaIoFile_TempFileLocker *)tempFileLocker {
  return JavaIoFile_tempFileLocker_;
}

+ (void)setTempFileLocker:(JavaIoFile_TempFileLocker *)tempFileLocker {
  JreOperatorRetainedAssign(&JavaIoFile_tempFileLocker_, nil, tempFileLocker);
}

+ (BOOL)caseSensitive {
  return JavaIoFile_caseSensitive_;
}

+ (BOOL *)caseSensitiveRef {
  return &JavaIoFile_caseSensitive_;
}

- (id)initWithJavaIoFile:(JavaIoFile *)dir
            withNSString:(NSString *)name {
  if (self = [super init]) {
    if (name == nil) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    if (dir == nil) {
      JavaIoFile_set_path_(self, [self fixSlashesWithNSString:name]);
    }
    else {
      JavaIoFile_set_path_(self, [self calculatePathWithNSString:[dir getPath] withNSString:name]);
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithNSString:(NSString *)path {
  if (self = [super init]) {
    JavaIoFile_set_path_(self, [self fixSlashesWithNSString:path]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithNSString:(NSString *)dirPath
          withNSString:(NSString *)name {
  if (self = [super init]) {
    if (name == nil) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    if (dirPath == nil) {
      JavaIoFile_set_path_(self, [self fixSlashesWithNSString:name]);
    }
    else {
      JavaIoFile_set_path_(self, [self calculatePathWithNSString:dirPath withNSString:name]);
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (NSString *)calculatePathWithNSString:(NSString *)dirPath
                           withNSString:(NSString *)name {
  dirPath = [self fixSlashesWithNSString:dirPath];
  if (![((NSString *) nil_chk(name)) isEqual:JavaIoFile_EMPTY_STRING_] || [((NSString *) nil_chk(dirPath)) isEqual:JavaIoFile_EMPTY_STRING_]) {
    name = [self fixSlashesWithNSString:name];
    int separatorIndex = 0;
    while ((separatorIndex < [((NSString *) nil_chk(name)) length]) && ([name charAtWithInt:separatorIndex] == JavaIoFile_separatorChar)) {
      separatorIndex++;
    }
    if (separatorIndex > 0) {
      name = [name substring:separatorIndex endIndex:[name length]];
    }
    if ([((NSString *) nil_chk(dirPath)) length] > 0 && ([dirPath charAtWithInt:[dirPath length] - 1] == JavaIoFile_separatorChar)) {
      return [NSString stringWithFormat:@"%@%@", dirPath, name];
    }
    return [NSString stringWithFormat:@"%@/%@", dirPath, name];
  }
  return dirPath;
}

+ (BOOL)isCaseSensitiveImpl {
  // True for iOS, not OS X/simulator.
  struct utsname systemInfo;
  uname(&systemInfo);
  if (strcmp(systemInfo.machine, "i386") == 0 || strncmp(systemInfo.machine, "x86", 3) == 0) {
    return false;
  }
  return true;
}

+ (IOSObjectArray *)listRoots {
  return [IOSObjectArray arrayWithObjects:(id[]){ [[[JavaIoFile alloc] initWithNSString:@"/"] autorelease] } count:1 type:[IOSClass classWithClass:[JavaIoFile class]]];
}

- (NSString *)fixSlashesWithNSString:(NSString *)origPath {
  int uncIndex = 1;
  int length = [((NSString *) nil_chk(origPath)) length], newLength = 0;
  uncIndex = 0;
  BOOL foundSlash = NO;
  IOSCharArray *newPath = [origPath toCharArray];
  for (int i = 0; i < length; i++) {
    unichar pathChar = IOSCharArray_Get(nil_chk(newPath), i);
    if (pathChar == '/') {
      if ((foundSlash && i == uncIndex) || !foundSlash) {
        (*IOSCharArray_GetRef(newPath, newLength++)) = JavaIoFile_separatorChar;
        foundSlash = YES;
      }
    }
    else {
      if (pathChar == ':' && uncIndex > 0 && (newLength == 2 || (newLength == 3 && IOSCharArray_Get(newPath, 1) == JavaIoFile_separatorChar)) && IOSCharArray_Get(newPath, 0) == JavaIoFile_separatorChar) {
        (*IOSCharArray_GetRef(newPath, 0)) = IOSCharArray_Get(newPath, newLength - 1);
        newLength = 1;
        uncIndex = 2;
      }
      (*IOSCharArray_GetRef(newPath, newLength++)) = pathChar;
      foundSlash = NO;
    }
  }
  if (foundSlash && (newLength > (uncIndex + 1) || (newLength == 2 && IOSCharArray_Get(nil_chk(newPath), 0) != JavaIoFile_separatorChar))) {
    newLength--;
  }
  return [NSString stringWithCharacters:newPath offset:0 length:newLength];
}

- (BOOL)canRead {
  if ([((NSString *) nil_chk(path_)) length] == 0) {
    return NO;
  }
  NSString *pp = [self properPathWithBoolean:YES];
  return [self existsImplWithNSString:pp] && [self isReadableImplWithNSString:pp];
}

- (BOOL)canWrite {
  BOOL exists = NO;
  if ([((NSString *) nil_chk(path_)) length] > 0) {
    exists = [self existsImplWithNSString:[self properPathWithBoolean:YES]];
  }
  return exists && [self isWritableImplWithNSString:[self properPathWithBoolean:YES]];
}

- (int)compareToWithId:(JavaIoFile *)another {
  if (another != nil && ![another isKindOfClass:[JavaIoFile class]]) {
    @throw [[[JavaLangClassCastException alloc] init] autorelease];
  }
  if (JavaIoFile_caseSensitive_) {
    return [((NSString *) nil_chk([self getPath])) compareToWithId:[((JavaIoFile *) nil_chk(another)) getPath]];
  }
  return [((NSString *) nil_chk([self getPath])) compareToIgnoreCase:[((JavaIoFile *) nil_chk(another)) getPath]];
}

- (BOOL)delete__ {
  NSString *propPath = [self properPathWithBoolean:YES];
  if (([((NSString *) nil_chk(propPath)) length] != 0) && [self isDirectoryImplWithNSString:propPath]) {
    return [self deleteDirImplWithNSString:propPath];
  }
  return [self deleteFileImplWithNSString:propPath];
}

- (BOOL)deleteDirImplWithNSString:(NSString *)filePath {
  NSArray *files =
  [[NSFileManager defaultManager] contentsOfDirectoryAtPath:filePath error:nil];
  if (!files || [files count] > 0) {  // Don't delete if non-empty.
  return false;
}
return [self deleteFileImplWithNSString:filePath];
}

- (BOOL)deleteFileImplWithNSString:(NSString *)filePath {
  NSFileManager *manager = [NSFileManager defaultManager];
  if (![manager fileExistsAtPath:filePath isDirectory:NULL]) {
    return NO;
  }
  if (![manager isDeletableFileAtPath:filePath]) {
    return NO;
  }
  return [[NSFileManager defaultManager] removeItemAtPath:filePath error:nil];
}

- (void)deleteOnExit {
  @throw [[[JavaLangAssertionError alloc] initWithId:@"not implemented"] autorelease];
}

- (BOOL)isEqual:(id)obj {
  if (!([obj isKindOfClass:[JavaIoFile class]])) {
    return NO;
  }
  if (!JavaIoFile_caseSensitive_) {
    return [((NSString *) nil_chk(path_)) equalsIgnoreCase:[((JavaIoFile *) nil_chk(obj)) getPath]];
  }
  return [((NSString *) nil_chk(path_)) isEqual:[((JavaIoFile *) nil_chk(obj)) getPath]];
}

- (BOOL)exists {
  if ([((NSString *) nil_chk(path_)) length] == 0) {
    return NO;
  }
  return [self existsImplWithNSString:[self properPathWithBoolean:YES]];
}

- (BOOL)existsImplWithNSString:(NSString *)filePath {
  return [[NSFileManager defaultManager] fileExistsAtPath:filePath];
}

- (NSString *)getAbsolutePath {
  return [self properPathWithBoolean:NO];
}

- (JavaIoFile *)getAbsoluteFile {
  return [[[JavaIoFile alloc] initWithNSString:[self getAbsolutePath]] autorelease];
}

- (NSString *)getCanonicalPath {
  return [self getAbsolutePath];
}

+ (IOSObjectArray *)__exceptions_getCanonicalPath {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (IOSByteArray *)resolveWithByteArray:(IOSByteArray *)newResult {
  int last = 1, nextSize, linkSize;
  IOSByteArray *linkPath = newResult, *bytes;
  BOOL done, inPlace;
  for (int i = 1; i <= (int) [((IOSByteArray *) nil_chk(newResult)) count]; i++) {
    if (i == (int) [newResult count] || IOSByteArray_Get(newResult, i) == JavaIoFile_separatorChar) {
      done = i >= (int) [newResult count] - 1;
      if (done && (int) [((IOSByteArray *) nil_chk(linkPath)) count] == 1) {
        return newResult;
      }
      inPlace = NO;
      if (linkPath == newResult) {
        bytes = newResult;
        if (!done) {
          inPlace = YES;
          (*IOSByteArray_GetRef(newResult, i)) = 0x0000;
        }
      }
      else {
        nextSize = i - last + 1;
        linkSize = (int) [((IOSByteArray *) nil_chk(linkPath)) count];
        if (IOSByteArray_Get(linkPath, linkSize - 1) == JavaIoFile_separatorChar) {
          linkSize--;
        }
        bytes = [IOSByteArray arrayWithLength:linkSize + nextSize];
        [JavaLangSystem arraycopyWithId:linkPath withInt:0 withId:bytes withInt:0 withInt:linkSize];
        [JavaLangSystem arraycopyWithId:newResult withInt:last - 1 withId:bytes withInt:linkSize withInt:nextSize];
      }
      if (done) {
        return bytes;
      }
      linkPath = [self resolveLinkWithByteArray:bytes withInt:inPlace ? i : (int) [((IOSByteArray *) nil_chk(bytes)) count] withBoolean:YES];
      if (inPlace) {
        (*IOSByteArray_GetRef(newResult, i)) = '/';
      }
      last = i + 1;
    }
  }
  @throw [[[JavaLangInternalError alloc] init] autorelease];
}

+ (IOSObjectArray *)__exceptions_resolveWithByteArray_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (IOSByteArray *)resolveLinkWithByteArray:(IOSByteArray *)pathBytes
                                   withInt:(int)length
                               withBoolean:(BOOL)resolveAbsolute {
  BOOL restart = NO;
  IOSByteArray *linkBytes, *temp;
  do {
    linkBytes = [((NSString *) nil_chk([self getLinkImplWithNSString:[NSString stringWithBytes:pathBytes]])) getBytes];
    if (linkBytes == pathBytes) {
      break;
    }
    if (IOSByteArray_Get(nil_chk(linkBytes), 0) == JavaIoFile_separatorChar) {
      restart = resolveAbsolute;
      pathBytes = linkBytes;
    }
    else {
      int last = length - 1;
      while (IOSByteArray_Get(nil_chk(pathBytes), last) != JavaIoFile_separatorChar) {
        last--;
      }
      last++;
      temp = [IOSByteArray arrayWithLength:last + (int) [linkBytes count]];
      [JavaLangSystem arraycopyWithId:pathBytes withInt:0 withId:temp withInt:0 withInt:last];
      [JavaLangSystem arraycopyWithId:linkBytes withInt:0 withId:temp withInt:last withInt:(int) [linkBytes count]];
      pathBytes = temp;
    }
    length = (int) [((IOSByteArray *) nil_chk(pathBytes)) count];
  }
  while ([self existsImplWithNSString:[NSString stringWithBytes:pathBytes]]);
  if (restart) {
    return [self resolveWithByteArray:pathBytes];
  }
  return pathBytes;
}

+ (IOSObjectArray *)__exceptions_resolveLinkWithByteArray_withInt_withBoolean_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (JavaIoFile *)getCanonicalFile {
  return [[[JavaIoFile alloc] initWithNSString:[self getCanonicalPath]] autorelease];
}

+ (IOSObjectArray *)__exceptions_getCanonicalFile {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (NSString *)getName {
  int separatorIndex = [((NSString *) nil_chk(path_)) lastIndexOfString:JavaIoFile_separator_];
  return (separatorIndex < 0) ? path_ : [path_ substring:separatorIndex + 1 endIndex:[path_ length]];
}

- (NSString *)getParent {
  int length = [((NSString *) nil_chk(path_)) length], firstInPath = 0;
  int index = [path_ lastIndexOf:JavaIoFile_separatorChar];
  if (index == -1 && firstInPath > 0) {
    index = 2;
  }
  if (index == -1 || [path_ charAtWithInt:length - 1] == JavaIoFile_separatorChar) {
    return nil;
  }
  if ([path_ indexOf:JavaIoFile_separatorChar] == index && [path_ charAtWithInt:firstInPath] == JavaIoFile_separatorChar) {
    return [path_ substring:0 endIndex:index + 1];
  }
  return [path_ substring:0 endIndex:index];
}

- (JavaIoFile *)getParentFile {
  NSString *tempParent = [self getParent];
  if (tempParent == nil) {
    return nil;
  }
  return [[[JavaIoFile alloc] initWithNSString:tempParent] autorelease];
}

- (NSString *)getPath {
  return path_;
}

- (NSUInteger)hash {
  if (JavaIoFile_caseSensitive_) {
    return [((NSString *) nil_chk(path_)) hash] ^ 1234321;
  }
  return [((NSString *) nil_chk([((NSString *) nil_chk(path_)) lowercaseStringWithJRELocale:[JavaUtilLocale ENGLISH]])) hash] ^ 1234321;
}

- (BOOL)isAbsolute {
  return ([((NSString *) nil_chk(path_)) length] > 0 && [path_ charAtWithInt:0] == JavaIoFile_separatorChar);
}

- (BOOL)isDirectory {
  if ([((NSString *) nil_chk(path_)) length] == 0) {
    return NO;
  }
  return [self isDirectoryImplWithNSString:[self properPathWithBoolean:YES]];
}

- (BOOL)isDirectoryImplWithNSString:(NSString *)filePath {
  BOOL isDir;
  BOOL exists = [[NSFileManager defaultManager] fileExistsAtPath:filePath isDirectory:&isDir];
  return exists && isDir;
}

- (BOOL)isFile {
  if ([((NSString *) nil_chk(path_)) length] == 0) {
    return NO;
  }
  return [self isFileImplWithNSString:[self properPathWithBoolean:YES]];
}

- (BOOL)isFileImplWithNSString:(NSString *)filePath {
  BOOL isDir;
  BOOL exists = [[NSFileManager defaultManager] fileExistsAtPath:filePath isDirectory:&isDir];
  return exists && !isDir;
}

- (BOOL)isHidden {
  if ([((NSString *) nil_chk(path_)) length] == 0) {
    return NO;
  }
  return [self isHiddenImplWithNSString:[self properPathWithBoolean:YES]];
}

- (BOOL)isHiddenImplWithNSString:(NSString *)filePath {
  return [((NSString *) nil_chk([self getName])) hasPrefix:@"."];
}

- (BOOL)isReadableImplWithNSString:(NSString *)filePath {
  return [[NSFileManager defaultManager] isReadableFileAtPath:filePath];
}

- (BOOL)isWritableImplWithNSString:(NSString *)filePath {
  return [[NSFileManager defaultManager] isWritableFileAtPath:filePath];
}

- (NSString *)getLinkImplWithNSString:(NSString *)filePath {
  return [[NSFileManager defaultManager] destinationOfSymbolicLinkAtPath:filePath error:nil];
}

- (long long int)lastModified {
  long long int result = [self lastModifiedImplWithNSString:[self properPathWithBoolean:YES]];
  if (result == -1 || result == 0) {
    return 0;
  }
  return result;
}

- (long long int)lastModifiedImplWithNSString:(NSString *)filePath {
  NSDictionary *attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath
  error:nil];
  NSDate *lastModified = [attributes fileModificationDate];
  NSTimeInterval seconds = [lastModified timeIntervalSince1970];
  return llround(seconds * 1000);
}

- (BOOL)setLastModifiedWithLong:(long long int)time {
  if (time < 0) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"time must be positive"] autorelease];
  }
  return ([self setLastModifiedImplWithNSString:[self properPathWithBoolean:YES] withLong:time]);
}

- (BOOL)setAttributeWithNSString:(NSString *)path
                    withNSString:(NSString *)attributeKey
                          withId:(id)value {
  NSMutableDictionary *attributes = [NSMutableDictionary dictionaryWithCapacity:1];
  [attributes setObject:value forKey:attributeKey];
  return [[NSFileManager defaultManager] setAttributes:attributes ofItemAtPath:path error:nil];
}

- (BOOL)setLastModifiedImplWithNSString:(NSString *)path
                               withLong:(long long int)time {
  NSTimeInterval seconds = time / 1000.0;
  NSDate *lastModified = [NSDate dateWithTimeIntervalSince1970:seconds];
  return [self setAttributeWithNSString:path
  withNSString:NSFileModificationDate
  withId:lastModified];
}

- (BOOL)setReadOnly {
  return ([self setReadOnlyImplWithNSString:[self properPathWithBoolean:YES]]);
}

- (BOOL)setReadOnlyImplWithNSString:(NSString *)path {
  return [self setAttributeWithNSString:path
  withNSString:NSFileImmutable
  withId:[NSNumber numberWithBool:YES]];
}

- (long long int)length {
  return [self lengthImplWithNSString:[self properPathWithBoolean:YES]];
}

- (long long int)lengthImplWithNSString:(NSString *)filePath {
  return [[[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil] fileSize];
}

- (IOSObjectArray *)list {
  if ([((NSString *) nil_chk(path_)) length] == 0) {
    return nil;
  }
  NSString *bs = [self properPathWithBoolean:YES];
  if (![self isDirectoryImplWithNSString:bs] || ![self existsImplWithNSString:bs] || ![self isReadableImplWithNSString:bs]) {
    return nil;
  }
  IOSObjectArray *implList = [JavaIoFile listImplWithNSString:bs];
  if (implList == nil) {
    return [IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSString class]]];
  }
  return implList;
}

- (IOSObjectArray *)listFiles {
  IOSObjectArray *tempNames = [self list];
  if (tempNames == nil) {
    return nil;
  }
  int resultLength = (int) [((IOSObjectArray *) nil_chk(tempNames)) count];
  IOSObjectArray *results = [IOSObjectArray arrayWithLength:resultLength type:[IOSClass classWithClass:[JavaIoFile class]]];
  for (int i = 0; i < resultLength; i++) {
    IOSObjectArray_Set(results, i, [[[JavaIoFile alloc] initWithJavaIoFile:self withNSString:IOSObjectArray_Get(tempNames, i)] autorelease]);
  }
  return results;
}

- (IOSObjectArray *)listFilesWithJavaIoFilenameFilter:(id<JavaIoFilenameFilter>)filter {
  IOSObjectArray *tempNames = [self listWithJavaIoFilenameFilter:filter];
  if (tempNames == nil) {
    return nil;
  }
  int resultLength = (int) [((IOSObjectArray *) nil_chk(tempNames)) count];
  IOSObjectArray *results = [IOSObjectArray arrayWithLength:resultLength type:[IOSClass classWithClass:[JavaIoFile class]]];
  for (int i = 0; i < resultLength; i++) {
    IOSObjectArray_Set(results, i, [[[JavaIoFile alloc] initWithJavaIoFile:self withNSString:IOSObjectArray_Get(tempNames, i)] autorelease]);
  }
  return results;
}

- (IOSObjectArray *)listFilesWithJavaIoFileFilter:(id<JavaIoFileFilter>)filter {
  if ([((NSString *) nil_chk(path_)) length] == 0) {
    return nil;
  }
  NSString *bs = [self properPathWithBoolean:YES];
  if (![self isDirectoryImplWithNSString:bs] || ![self existsImplWithNSString:bs] || ![self isReadableImplWithNSString:bs]) {
    return nil;
  }
  IOSObjectArray *implList = [JavaIoFile listImplWithNSString:bs];
  if (implList == nil) {
    return [IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[JavaIoFile class]]];
  }
  id<JavaUtilList> tempResult = [[[JavaUtilArrayList alloc] init] autorelease];
  for (int index = 0; index < (int) [((IOSObjectArray *) nil_chk(implList)) count]; index++) {
    NSString *aName = [NSString stringWithString:IOSObjectArray_Get(implList, index)];
    JavaIoFile *aFile = [[[JavaIoFile alloc] initWithJavaIoFile:self withNSString:aName] autorelease];
    if (filter == nil || [filter acceptWithJavaIoFile:aFile]) {
      [tempResult addWithId:aFile];
    }
  }
  return [tempResult toArrayWithNSObjectArray:[IOSObjectArray arrayWithLength:[tempResult size] type:[IOSClass classWithClass:[JavaIoFile class]]]];
}

- (IOSObjectArray *)listWithJavaIoFilenameFilter:(id<JavaIoFilenameFilter>)filter {
  if ([((NSString *) nil_chk(path_)) length] == 0) {
    return nil;
  }
  NSString *bs = [self properPathWithBoolean:YES];
  if (![self isDirectoryImplWithNSString:bs] || ![self existsImplWithNSString:bs] || ![self isReadableImplWithNSString:bs]) {
    return nil;
  }
  IOSObjectArray *implList = [JavaIoFile listImplWithNSString:bs];
  if (implList == nil) {
    return [IOSObjectArray arrayWithLength:0 type:[IOSClass classWithClass:[NSString class]]];
  }
  id<JavaUtilList> tempResult = [[[JavaUtilArrayList alloc] init] autorelease];
  for (int index = 0; index < (int) [((IOSObjectArray *) nil_chk(implList)) count]; index++) {
    NSString *aName = [NSString stringWithString:IOSObjectArray_Get(implList, index)];
    if (filter == nil || [filter acceptWithJavaIoFile:self withNSString:aName]) {
      [tempResult addWithId:aName];
    }
  }
  return [tempResult toArrayWithNSObjectArray:[IOSObjectArray arrayWithLength:[tempResult size] type:[IOSClass classWithClass:[NSString class]]]];
}

+ (IOSObjectArray *)listImplWithNSString:(NSString *)path {
  NSArray *fileArray =
  [[NSFileManager defaultManager] contentsOfDirectoryAtPath:path error:nil];
  IOSObjectArray *files =
  [[IOSObjectArray alloc] initWithLength:[fileArray count]
  type:[IOSClass classWithClass:[NSString class]]];
  #if ! __has_feature(objc_arc)
  [files autorelease];
  #endif
  NSUInteger nFiles = [fileArray count];
  for (NSUInteger i = 0; i < nFiles; i++) {
    [files replaceObjectAtIndex:i withObject:[fileArray objectAtIndex:i]];
  }
  return files;
}

- (BOOL)mkdir {
  return [self mkdirImplWithNSString:[self properPathWithBoolean:YES]];
}

- (BOOL)mkdirImplWithNSString:(NSString *)filePath {
  return [[NSFileManager defaultManager] createDirectoryAtPath:filePath
  withIntermediateDirectories:NO
  attributes:nil
  error:nil];
}

- (BOOL)mkdirs {
  if ([self exists]) {
    return NO;
  }
  if ([self mkdir]) {
    return YES;
  }
  NSString *parentDir = [self getParent];
  if (parentDir == nil) {
    return NO;
  }
  return ([((JavaIoFile *) [[[JavaIoFile alloc] initWithNSString:parentDir] autorelease]) mkdirs] && [self mkdir]);
}

- (BOOL)createNewFile {
  if (0 == [((NSString *) nil_chk(path_)) length]) {
    @throw [[[JavaIoIOException alloc] initWithNSString:@"No such file or directory"] autorelease];
  }
  int result = [self newFileImplWithNSString:[self properPathWithBoolean:YES]];
  switch (result) {
    case 0:
    return YES;
    case 1:
    return NO;
    default:
    @throw [[[JavaIoIOException alloc] initWithNSString:[NSString stringWithFormat:@"Cannot create: %@", path_]] autorelease];
  }
}

+ (IOSObjectArray *)__exceptions_createNewFile {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)newFileImplWithNSString:(NSString *)filePath {
  if ([self existsImplWithNSString:filePath]) {
    return 1;
  }
  if ([[NSFileManager defaultManager] createFileAtPath:filePath
  contents:[NSData data]
  attributes:nil]) {
    return 0;
  }
  NSException *e = [[JavaIoIOException alloc] init];
  #if ! __has_feature(objc_arc)
  [e autorelease];
  #endif
  @throw e;
}

+ (JavaIoFile *)createTempFileWithNSString:(NSString *)prefix
                              withNSString:(NSString *)suffix {
  return [JavaIoFile createTempFileWithNSString:prefix withNSString:suffix withJavaIoFile:nil];
}

+ (IOSObjectArray *)__exceptions_createTempFileWithNSString_withNSString_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

+ (JavaIoFile *)createTempFileWithNSString:(NSString *)prefix
                              withNSString:(NSString *)suffix
                            withJavaIoFile:(JavaIoFile *)directory {
  if ([((NSString *) nil_chk(prefix)) length] < 3) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Prefix must be at least 3 characters"] autorelease];
  }
  NSString *newSuffix = suffix == nil ? @".tmp" : suffix;
  JavaIoFile *tmpDirFile;
  if (directory == nil) {
    NSString *tmpDir = [JavaLangSystem getPropertyWithNSString:@"java.io.tmpdir" withNSString:@"."];
    tmpDirFile = [[[JavaIoFile alloc] initWithNSString:tmpDir] autorelease];
  }
  else {
    tmpDirFile = directory;
  }
  JavaIoFile *result;
  do {
    result = [JavaIoFile genTempFileWithNSString:prefix withNSString:newSuffix withJavaIoFile:tmpDirFile];
  }
  while (![((JavaIoFile *) nil_chk(result)) createNewFile]);
  return result;
}

+ (IOSObjectArray *)__exceptions_createTempFileWithNSString_withNSString_withJavaIoFile_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

+ (JavaIoFile *)genTempFileWithNSString:(NSString *)prefix
                           withNSString:(NSString *)suffix
                         withJavaIoFile:(JavaIoFile *)directory {
  int identify = 0;
  @synchronized (JavaIoFile_tempFileLocker_) {
    if (JavaIoFile_counter_ == 0) {
      int newInt = [((JavaUtilRandom *) [[[JavaUtilRandom alloc] init] autorelease]) nextInt];
      JavaIoFile_counter_ = ((newInt / 65535) & (int) 0xFFFF) + (int) 0x2710;
      JavaIoFile_counterBase_ = JavaIoFile_counter_;
    }
    identify = JavaIoFile_counter_++;
  }
  JavaLangStringBuilder *newName = [[[JavaLangStringBuilder alloc] init] autorelease];
  [newName appendWithNSString:prefix];
  [newName appendWithInt:JavaIoFile_counterBase_];
  [newName appendWithInt:identify];
  [newName appendWithNSString:suffix];
  return [[[JavaIoFile alloc] initWithJavaIoFile:directory withNSString:[newName description]] autorelease];
}

- (NSString *)properPathWithBoolean:(BOOL)internal {
  if (properPath__ != nil) {
    return properPath__;
  }
  if ([self isAbsolute]) {
    return path_;
  }
  NSString *userdir;
  userdir = [JavaLangSystem getPropertyWithNSString:@"user.dir"];
  if ([((NSString *) nil_chk(path_)) length] == 0) {
    return JavaIoFile_set_properPath__(self, userdir);
  }
  int length = [((NSString *) nil_chk(userdir)) length];
  NSString *result = userdir;
  if ([userdir charAtWithInt:length - 1] != JavaIoFile_separatorChar) {
    if ([path_ charAtWithInt:0] != JavaIoFile_separatorChar) {
      result = [NSString stringWithFormat:@"%@/", result];
    }
  }
  else if ([path_ charAtWithInt:0] == JavaIoFile_separatorChar) {
    result = [result substring:0 endIndex:length - 2];
  }
  result = [NSString stringWithFormat:@"%@%@", result, path_];
  return JavaIoFile_set_properPath__(self, result);
}

- (BOOL)renameToWithJavaIoFile:(JavaIoFile *)dest {
  return [self renameToImplWithNSString:[self properPathWithBoolean:YES] withNSString:[((JavaIoFile *) nil_chk(dest)) properPathWithBoolean:YES]];
}

- (BOOL)renameToImplWithNSString:(NSString *)pathExist
                    withNSString:(NSString *)pathNew {
  return [[NSFileManager defaultManager] moveItemAtPath:pathExist toPath:pathNew error:nil];
}

- (NSString *)description {
  return path_;
}

- (NSString *)getAbsoluteName {
  JavaIoFile *f = [self getAbsoluteFile];
  NSString *name = [((JavaIoFile *) nil_chk(f)) getPath];
  if ([f isDirectory] && [name charAtWithInt:[((NSString *) nil_chk(name)) length] - 1] != JavaIoFile_separatorChar) {
    name = [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) [[[JavaLangStringBuilder alloc] initWithInt:[name length] + 1] autorelease]) appendWithNSString:name])) appendWithChar:'/'])) description];
  }
  return name;
}

+ (void)initialize {
  if (self == [JavaIoFile class]) {
    JavaIoFile_counter_ = 0;
    JavaIoFile_counterBase_ = 0;
    JreOperatorRetainedAssign(&JavaIoFile_tempFileLocker_, nil, [[[JavaIoFile_TempFileLocker alloc] init] autorelease]);
    {
      JavaIoFile_caseSensitive_ = [JavaIoFile isCaseSensitiveImpl];
    }
  }
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaIoFile_set_properPath__(self, nil);
  JavaIoFile_set_path_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaIoFile *)other {
  [super copyAllFieldsTo:other];
  JavaIoFile_set_path_(other, path_);
  JavaIoFile_set_properPath__(other, properPath__);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:path_ name:@"path"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:properPath__ name:@"properPath_"]];
  return result;
}

@end
@implementation JavaIoFile_TempFileLocker

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

@end
