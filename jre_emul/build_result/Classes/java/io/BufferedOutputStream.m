//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//
//  Created by Larry Tin <dev@goodow.com>
//

#include "IOSByteArray.h"
#include "IOSClass.h"
#include "java/io/BufferedOutputStream.h"
#include "java/io/IOException.h"
#include "java/io/OutputStream.h"
#include "java/lang/ArrayIndexOutOfBoundsException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/System.h"

@implementation JavaIoBufferedOutputStream

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  if (self = [super initWithJavaIoOutputStream:outArg]) {
    JavaIoBufferedOutputStream_set_buf_(self, [IOSByteArray arrayWithLength:8192]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                         withInt:(int)size {
  if (self = [super initWithJavaIoOutputStream:outArg]) {
    if (size <= 0) {
      @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"size must be > 0"] autorelease];
    }
    JavaIoBufferedOutputStream_set_buf_(self, [IOSByteArray arrayWithLength:size]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)flush {
  @synchronized(self) {
    {
      [self flushInternal];
      [((JavaIoOutputStream *) nil_chk(out_)) flush];
    }
  }
}

+ (IOSObjectArray *)__exceptions_flush {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)writeWithByteArray:(IOSByteArray *)buffer
                   withInt:(int)offset
                   withInt:(int)length {
  @synchronized(self) {
    {
      IOSByteArray *internalBuffer = buf_;
      if (internalBuffer != nil && length >= (int) [internalBuffer count]) {
        [self flushInternal];
        [((JavaIoOutputStream *) nil_chk(out_)) writeWithByteArray:buffer withInt:offset withInt:length];
        return;
      }
      if (buffer == nil) {
        @throw [[[JavaLangNullPointerException alloc] initWithNSString:@"buffer is null"] autorelease];
      }
      if (offset < 0 || offset > (int) [((IOSByteArray *) nil_chk(buffer)) count] - length) {
        @throw [[[JavaLangArrayIndexOutOfBoundsException alloc] initWithNSString:[NSString stringWithFormat:@"Offset out of bounds: %d", offset]] autorelease];
      }
      if (length < 0) {
        @throw [[[JavaLangArrayIndexOutOfBoundsException alloc] initWithNSString:[NSString stringWithFormat:@"Length out of bounds: %d", length]] autorelease];
      }
      if (internalBuffer == nil) {
        @throw [[[JavaIoIOException alloc] initWithNSString:@"Stream is closed"] autorelease];
      }
      if (length >= ((int) [((IOSByteArray *) nil_chk(internalBuffer)) count] - count_)) {
        [self flushInternal];
      }
      [JavaLangSystem arraycopyWithId:buffer withInt:offset withId:internalBuffer withInt:count_ withInt:length];
      count_ += length;
    }
  }
}

+ (IOSObjectArray *)__exceptions_writeWithByteArray_withInt_withInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)close {
  @synchronized(self) {
    {
      if (buf_ == nil) {
        return;
      }
      @try {
        [super close];
      }
      @finally {
        JavaIoBufferedOutputStream_set_buf_(self, nil);
      }
    }
  }
}

+ (IOSObjectArray *)__exceptions_close {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)writeWithInt:(int)oneByte {
  @synchronized(self) {
    {
      IOSByteArray *internalBuffer = buf_;
      if (internalBuffer == nil) {
        @throw [[[JavaIoIOException alloc] initWithNSString:@"Stream is closed"] autorelease];
      }
      if (count_ == (int) [((IOSByteArray *) nil_chk(internalBuffer)) count]) {
        [((JavaIoOutputStream *) nil_chk(out_)) writeWithByteArray:internalBuffer withInt:0 withInt:count_];
        count_ = 0;
      }
      (*IOSByteArray_GetRef(internalBuffer, count_++)) = (char) oneByte;
    }
  }
}

+ (IOSObjectArray *)__exceptions_writeWithInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)flushInternal {
  if (count_ > 0) {
    [((JavaIoOutputStream *) nil_chk(out_)) writeWithByteArray:buf_ withInt:0 withInt:count_];
    count_ = 0;
  }
}

+ (IOSObjectArray *)__exceptions_flushInternal {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaIoBufferedOutputStream_set_buf_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaIoBufferedOutputStream *)other {
  [super copyAllFieldsTo:other];
  JavaIoBufferedOutputStream_set_buf_(other, buf_);
  other->count_ = count_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:buf_ name:@"buf"]];
  return result;
}

@end
