//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/io/PushbackReader.java
//
//  Created by retechretech on 13-9-25.
//

#include "IOSCharArray.h"
#include "IOSClass.h"
#include "java/io/IOException.h"
#include "java/io/PushbackReader.h"
#include "java/io/Reader.h"
#include "java/lang/ArrayIndexOutOfBoundsException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/System.h"

@implementation JavaIoPushbackReader

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithJavaIoReader:(JavaIoReader *)inArg {
  if (self = [super initWithJavaIoReader:inArg]) {
    JavaIoPushbackReader_set_buf_(self, [IOSCharArray arrayWithLength:1]);
    pos_ = 1;
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaIoReader:(JavaIoReader *)inArg
                   withInt:(int)size {
  if (self = [super initWithJavaIoReader:inArg]) {
    if (size <= 0) {
      @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"size must be > 0"] autorelease];
    }
    JavaIoPushbackReader_set_buf_(self, [IOSCharArray arrayWithLength:size]);
    pos_ = size;
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)close {
  @synchronized (lock_) {
    JavaIoPushbackReader_set_buf_(self, nil);
    [((JavaIoReader *) nil_chk(in_)) close];
  }
}

+ (IOSObjectArray *)__exceptions_close {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)markWithInt:(int)readAheadLimit {
  @throw [[[JavaIoIOException alloc] initWithNSString:@"Mark/Reset not supported"] autorelease];
}

+ (IOSObjectArray *)__exceptions_markWithInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (BOOL)markSupported {
  return NO;
}

- (int)read {
  @synchronized (lock_) {
    if (buf_ == nil) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"Stream is closed"] autorelease];
    }
    if (pos_ < (int) [((IOSCharArray *) nil_chk(buf_)) count]) {
      return IOSCharArray_Get(buf_, pos_++);
    }
    return [((JavaIoReader *) nil_chk(in_)) read];
  }
}

+ (IOSObjectArray *)__exceptions_read {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)readWithCharArray:(IOSCharArray *)buffer
                 withInt:(int)offset
                 withInt:(int)count {
  @synchronized (lock_) {
    if (nil == buf_) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"Stream is closed"] autorelease];
    }
    if (offset < 0 || count < 0 || offset > (int) [((IOSCharArray *) nil_chk(buffer)) count] - count) {
      @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
    }
    int copiedChars = 0;
    int copyLength = 0;
    int newOffset = offset;
    if (pos_ < (int) [((IOSCharArray *) nil_chk(buf_)) count]) {
      copyLength = ((int) [buf_ count] - pos_ >= count) ? count : (int) [buf_ count] - pos_;
      [JavaLangSystem arraycopyWithId:buf_ withInt:pos_ withId:buffer withInt:newOffset withInt:copyLength];
      newOffset += copyLength;
      copiedChars += copyLength;
      pos_ += copyLength;
    }
    if (copyLength == count) {
      return count;
    }
    int inCopied = [((JavaIoReader *) nil_chk(in_)) readWithCharArray:buffer withInt:newOffset withInt:count - copiedChars];
    if (inCopied > 0) {
      return inCopied + copiedChars;
    }
    if (copiedChars == 0) {
      return inCopied;
    }
    return copiedChars;
  }
}

+ (IOSObjectArray *)__exceptions_readWithCharArray_withInt_withInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (BOOL)ready {
  @synchronized (lock_) {
    if (buf_ == nil) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"Reader is closed"] autorelease];
    }
    return ((int) [((IOSCharArray *) nil_chk(buf_)) count] - pos_ > 0 || [((JavaIoReader *) nil_chk(in_)) ready]);
  }
}

+ (IOSObjectArray *)__exceptions_ready {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)reset {
  @throw [[[JavaIoIOException alloc] initWithNSString:@"Mark/Reset not supported"] autorelease];
}

+ (IOSObjectArray *)__exceptions_reset {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)unreadWithCharArray:(IOSCharArray *)buffer {
  [self unreadWithCharArray:buffer withInt:0 withInt:(int) [((IOSCharArray *) nil_chk(buffer)) count]];
}

+ (IOSObjectArray *)__exceptions_unreadWithCharArray_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)unreadWithCharArray:(IOSCharArray *)buffer
                    withInt:(int)offset
                    withInt:(int)length {
  @synchronized (lock_) {
    if (buf_ == nil) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"Stream is closed"] autorelease];
    }
    if (length > pos_) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"Pushback buffer full"] autorelease];
    }
    if (offset > (int) [((IOSCharArray *) nil_chk(buffer)) count] - length || offset < 0) {
      @throw [[[JavaLangArrayIndexOutOfBoundsException alloc] initWithNSString:[NSString stringWithFormat:@"Offset out of bounds: %d", offset]] autorelease];
    }
    if (length < 0) {
      @throw [[[JavaLangArrayIndexOutOfBoundsException alloc] initWithNSString:[NSString stringWithFormat:@"Length out of bounds: %d", length]] autorelease];
    }
    for (int i = offset + length - 1; i >= offset; i--) {
      [self unreadWithInt:IOSCharArray_Get(buffer, i)];
    }
  }
}

+ (IOSObjectArray *)__exceptions_unreadWithCharArray_withInt_withInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)unreadWithInt:(int)oneChar {
  @synchronized (lock_) {
    if (buf_ == nil) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"Stream is closed"] autorelease];
    }
    if (pos_ == 0) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"Pushback buffer full"] autorelease];
    }
    (*IOSCharArray_GetRef(nil_chk(buf_), --pos_)) = (unichar) oneChar;
  }
}

+ (IOSObjectArray *)__exceptions_unreadWithInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (long long int)skipWithLong:(long long int)count {
  if (count < 0) {
    @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
  }
  @synchronized (lock_) {
    if (buf_ == nil) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"Stream is closed"] autorelease];
    }
    if (count == 0) {
      return 0;
    }
    long long int inSkipped;
    int availableFromBuffer = (int) [((IOSCharArray *) nil_chk(buf_)) count] - pos_;
    if (availableFromBuffer > 0) {
      long long int requiredFromIn = count - availableFromBuffer;
      if (requiredFromIn <= 0) {
        pos_ += count;
        return count;
      }
      pos_ += availableFromBuffer;
      inSkipped = [((JavaIoReader *) nil_chk(in_)) skipWithLong:requiredFromIn];
    }
    else {
      inSkipped = [((JavaIoReader *) nil_chk(in_)) skipWithLong:count];
    }
    return inSkipped + availableFromBuffer;
  }
}

+ (IOSObjectArray *)__exceptions_skipWithLong_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaIoPushbackReader_set_buf_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaIoPushbackReader *)other {
  [super copyAllFieldsTo:other];
  JavaIoPushbackReader_set_buf_(other, buf_);
  other->pos_ = pos_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:buf_ name:@"buf"]];
  return result;
}

@end
