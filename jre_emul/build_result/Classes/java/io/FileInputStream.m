//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//
//  Created by Larry Tin <dev@goodow.com>
//

#include "IOSByteArray.h"
#include "IOSClass.h"
#include "java/io/File.h"
#include "java/io/FileDescriptor.h"
#include "java/io/FileInputStream.h"
#include "java/io/FileNotFoundException.h"
#include "java/io/IOException.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/NullPointerException.h"
#import <fcntl.h>
#import <sys/ioctl.h>

@implementation JavaIoFileInputStream

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initJavaIoFileInputStreamWithJavaIoFile:(JavaIoFile *)file {
  if (self = [super init]) {
    stream_ = JavaIoFileInputStream_INVALID_STREAM;
    JavaIoFileInputStream_set_repositioningLock_(self, [[[NSObject alloc] init] autorelease]);
    if (file == nil) {
      @throw [[[JavaLangNullPointerException alloc] initWithNSString:@"Argument must not be null"] autorelease];
    }
    if (![((JavaIoFile *) nil_chk(file)) exists]) {
      @throw [[[JavaIoFileNotFoundException alloc] initWithNSString:[file getPath]] autorelease];
    }
    JavaIoFileInputStream_set_fd_(self, [[[JavaIoFileDescriptor alloc] init] autorelease]);
    fd_->readOnly_ = YES;
    fd_->descriptor_ = [self openWithNSString:[file getAbsolutePath]];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaIoFile:(JavaIoFile *)file {
  return [self initJavaIoFileInputStreamWithJavaIoFile:file];
}

- (long long int)openWithNSString:(NSString *)path {
  return (long long) open([path UTF8String], O_RDONLY);
}

- (id)initWithJavaIoFileDescriptor:(JavaIoFileDescriptor *)fd {
  if (self = [super init]) {
    stream_ = JavaIoFileInputStream_INVALID_STREAM;
    JavaIoFileInputStream_set_repositioningLock_(self, [[[NSObject alloc] init] autorelease]);
    if (fd == nil) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    JavaIoFileInputStream_set_fd_(self, fd);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithNSString:(NSString *)fileName {
  return JreMemDebugAdd([self initJavaIoFileInputStreamWithJavaIoFile:nil == fileName ? (JavaIoFile *) check_class_cast(nil, [JavaIoFile class]) : [[[JavaIoFile alloc] initWithNSString:fileName] autorelease]]);
}

+ (IOSObjectArray *)__exceptions_JavaIoFileInputStreamWithNSString_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoFileNotFoundException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)available {
  [self openCheck];
  @synchronized (repositioningLock_) {
    if (fd_ == [JavaIoFileDescriptor in]) {
      return [self nativeTtyAvailable];
    }
    return [self nativeAvailableWithLong:((JavaIoFileDescriptor *) nil_chk(fd_))->descriptor_];
  }
}

+ (IOSObjectArray *)__exceptions_available {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)nativeAvailableWithLong:(long long int)descriptor {
  long long currentPosition = lseek(descriptor, 0L, SEEK_CUR);
  long long endPosition = lseek(descriptor, 0L, SEEK_END);
  lseek(descriptor, currentPosition, SEEK_SET);
  return (int) (endPosition - currentPosition);
}

- (int)nativeTtyAvailable {
  long long currentPosition = lseek(STDIN_FILENO, 0L, SEEK_CUR);
  if (currentPosition != -1) {
    long long endPosition = lseek(STDIN_FILENO, 0L, SEEK_END);
    lseek(STDIN_FILENO, currentPosition, SEEK_SET);
    if (endPosition >= currentPosition) {
      return endPosition - currentPosition;
    }
  }
  NSInteger available;
  if (ioctl(STDIN_FILENO, FIONREAD, &available) != -1) {
    return *(int *) &available;
  }
  return 0;
}

- (void)close {
  if (fd_ == nil) {
    return;
  }
  @synchronized (self) {
    if (((JavaIoFileDescriptor *) nil_chk(fd_))->descriptor_ >= 0) {
      [self nativeClose];
      fd_->descriptor_ = -1;
      stream_ = JavaIoFileInputStream_INVALID_STREAM;
    }
  }
}

+ (IOSObjectArray *)__exceptions_close {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)nativeClose {
  close(fd_->descriptor_);
}

- (void)dealloc {
  JreMemDebugRemove(self);
  [self close];
  JavaIoFileInputStream_set_repositioningLock_(self, nil);
  JavaIoFileInputStream_set_fd_(self, nil);
  [super dealloc];
}

+ (IOSObjectArray *)__exceptions_dealloc {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (JavaIoFileDescriptor *)getFD {
  return fd_;
}

+ (IOSObjectArray *)__exceptions_getFD {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)read {
  IOSByteArray *readed = [IOSByteArray arrayWithLength:1];
  int result = [self readWithByteArray:readed withInt:0 withInt:1];
  return result == -1 ? -1 : IOSByteArray_Get(readed, 0) & (int) 0xff;
}

+ (IOSObjectArray *)__exceptions_read {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)readWithByteArray:(IOSByteArray *)buffer {
  return [self readWithByteArray:buffer withInt:0 withInt:(int) [((IOSByteArray *) nil_chk(buffer)) count]];
}

+ (IOSObjectArray *)__exceptions_readWithByteArray_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)readWithByteArray:(IOSByteArray *)buffer
                 withInt:(int)offset
                 withInt:(int)count {
  if (buffer == nil) {
    @throw [[[JavaLangNullPointerException alloc] init] autorelease];
  }
  if (count > (int) [((IOSByteArray *) nil_chk(buffer)) count] - offset || count < 0 || offset < 0) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
  }
  if (0 == count) {
    return 0;
  }
  [self openCheck];
  @synchronized (repositioningLock_) {
    return [self nativeReadWithByteArray:buffer withInt:offset withInt:count];
  }
}

+ (IOSObjectArray *)__exceptions_readWithByteArray_withInt_withInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)nativeReadWithByteArray:(IOSByteArray *)buffer
                       withInt:(int)offset
                       withInt:(int)count {
  char *buf = malloc(count);
  @try {
    int n = read(fd_->descriptor_, buf, count);
    if (n == 0) {
      return -1;  // EOF reached
    }
    if (n == -1) {
      JavaIoIOException *e = [[JavaIoIOException alloc] init];
      #if ! __has_feature(objc_arc)
      [e autorelease];
      #endif
      @throw e;
    }
    [buffer replaceBytes:buf length:n offset:offset];
    return n;
  }
  @finally {
    free(buf);
  }
}

- (long long int)skipWithLong:(long long int)count {
  [self openCheck];
  if (count == 0) {
    return 0;
  }
  if (count < 0) {
    @throw [[[JavaIoIOException alloc] initWithNSString:@"Number of bytes to skip cannot be negative"] autorelease];
  }
  @synchronized (repositioningLock_) {
    return [self seekWithLong:count];
  }
}

+ (IOSObjectArray *)__exceptions_skipWithLong_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (long long int)seekWithLong:(long long int)count {
  long currentPosition = lseek(fd_->descriptor_, 0L, SEEK_CUR);
  long newPosition = lseek(fd_->descriptor_, count, SEEK_CUR);
  return newPosition - currentPosition;
}

- (void)openCheck {
  @synchronized(self) {
    {
      if (((JavaIoFileDescriptor *) nil_chk(fd_))->descriptor_ < 0) {
        @throw [[[JavaIoIOException alloc] init] autorelease];
      }
    }
  }
}

+ (IOSObjectArray *)__exceptions_openCheck {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)copyAllFieldsTo:(JavaIoFileInputStream *)other {
  [super copyAllFieldsTo:other];
  JavaIoFileInputStream_set_fd_(other, fd_);
  JavaIoFileInputStream_set_repositioningLock_(other, repositioningLock_);
  other->stream_ = stream_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:fd_ name:@"fd"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:repositioningLock_ name:@"repositioningLock"]];
  return result;
}

@end
