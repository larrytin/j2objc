//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//
//  Created by Larry Tin <dev@goodow.com>
//

#include "IOSByteArray.h"
#include "IOSCharArray.h"
#include "IOSClass.h"
#include "java/io/IOException.h"
#include "java/io/OutputStream.h"
#include "java/io/OutputStreamWriter.h"
#include "java/io/UnsupportedEncodingException.h"
#include "java/lang/Exception.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/StringIndexOutOfBoundsException.h"
#include "java/nio/Buffer.h"
#include "java/nio/ByteBuffer.h"
#include "java/nio/CharBuffer.h"
#include "java/nio/charset/Charset.h"
#include "java/nio/charset/CharsetEncoder.h"
#include "java/nio/charset/CoderResult.h"
#include "java/nio/charset/CodingErrorAction.h"
#include "org/apache/harmony/luni/util/HistoricalNamesUtil.h"

@implementation JavaIoOutputStreamWriter

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  if (self = [super initWithId:outArg]) {
    JavaIoOutputStreamWriter_set_bytes_(self, [JavaNioByteBuffer allocateWithInt:8192]);
    encoderFlush_ = NO;
    JavaIoOutputStreamWriter_set_out_(self, outArg);
    JavaIoOutputStreamWriter_set_encoder_(self, [((JavaNioCharsetCharset *) nil_chk([JavaNioCharsetCharset forNameWithNSString:@"ISO8859_1"])) newEncoder]);
    [((JavaNioCharsetCharsetEncoder *) nil_chk(encoder_)) onMalformedInputWithJavaNioCharsetCodingErrorAction:[JavaNioCharsetCodingErrorAction REPLACE]];
    [encoder_ onUnmappableCharacterWithJavaNioCharsetCodingErrorAction:[JavaNioCharsetCodingErrorAction REPLACE]];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                    withNSString:(NSString *)enc {
  if (self = [super initWithId:outArg]) {
    JavaIoOutputStreamWriter_set_bytes_(self, [JavaNioByteBuffer allocateWithInt:8192]);
    encoderFlush_ = NO;
    if (enc == nil) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    JavaIoOutputStreamWriter_set_out_(self, outArg);
    @try {
      JavaIoOutputStreamWriter_set_encoder_(self, [((JavaNioCharsetCharset *) nil_chk([JavaNioCharsetCharset forNameWithNSString:enc])) newEncoder]);
    }
    @catch (JavaLangException *e) {
      @throw [[[JavaIoUnsupportedEncodingException alloc] initWithNSString:enc] autorelease];
    }
    [((JavaNioCharsetCharsetEncoder *) nil_chk(encoder_)) onMalformedInputWithJavaNioCharsetCodingErrorAction:[JavaNioCharsetCodingErrorAction REPLACE]];
    [encoder_ onUnmappableCharacterWithJavaNioCharsetCodingErrorAction:[JavaNioCharsetCodingErrorAction REPLACE]];
    JreMemDebugAdd(self);
  }
  return self;
}

+ (IOSObjectArray *)__exceptions_JavaIoOutputStreamWriterWithJavaIoOutputStream_withNSString_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoUnsupportedEncodingException getClass] } count:1 type:[IOSClass getClass]];
}

- (id)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
       withJavaNioCharsetCharset:(JavaNioCharsetCharset *)cs {
  if (self = [super initWithId:outArg]) {
    JavaIoOutputStreamWriter_set_bytes_(self, [JavaNioByteBuffer allocateWithInt:8192]);
    encoderFlush_ = NO;
    JavaIoOutputStreamWriter_set_out_(self, outArg);
    JavaIoOutputStreamWriter_set_encoder_(self, [((JavaNioCharsetCharset *) nil_chk(cs)) newEncoder]);
    [((JavaNioCharsetCharsetEncoder *) nil_chk(encoder_)) onMalformedInputWithJavaNioCharsetCodingErrorAction:[JavaNioCharsetCodingErrorAction REPLACE]];
    [encoder_ onUnmappableCharacterWithJavaNioCharsetCodingErrorAction:[JavaNioCharsetCodingErrorAction REPLACE]];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
withJavaNioCharsetCharsetEncoder:(JavaNioCharsetCharsetEncoder *)enc {
  if (self = [super initWithId:outArg]) {
    JavaIoOutputStreamWriter_set_bytes_(self, [JavaNioByteBuffer allocateWithInt:8192]);
    encoderFlush_ = NO;
    [((JavaNioCharsetCharsetEncoder *) nil_chk(enc)) charset];
    JavaIoOutputStreamWriter_set_out_(self, outArg);
    JavaIoOutputStreamWriter_set_encoder_(self, enc);
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)close {
  @synchronized (lock_) {
    if (encoder_ != nil) {
      if (encoderFlush_) {
        JavaNioCharsetCoderResult *result = [encoder_ flushWithJavaNioByteBuffer:bytes_];
        while (![((JavaNioCharsetCoderResult *) nil_chk(result)) isUnderflow]) {
          if ([result isOverflow]) {
            [self flush];
            result = [encoder_ flushWithJavaNioByteBuffer:bytes_];
          }
          else {
            [result throwException];
          }
        }
      }
      [self flush];
      [((JavaIoOutputStream *) nil_chk(out_)) flush];
      [out_ close];
      JavaIoOutputStreamWriter_set_encoder_(self, nil);
      JavaIoOutputStreamWriter_set_bytes_(self, nil);
    }
  }
}

+ (IOSObjectArray *)__exceptions_close {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)flush {
  @synchronized (lock_) {
    [self checkStatus];
    int position;
    if ((position = [((JavaNioByteBuffer *) nil_chk(bytes_)) position]) > 0) {
      [bytes_ flip];
      [((JavaIoOutputStream *) nil_chk(out_)) writeWithByteArray:[bytes_ array] withInt:0 withInt:position];
      [bytes_ clear];
    }
    [((JavaIoOutputStream *) nil_chk(out_)) flush];
  }
}

+ (IOSObjectArray *)__exceptions_flush {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)checkStatus {
  if (encoder_ == nil) {
    @throw [[[JavaIoIOException alloc] initWithNSString:@"Writer is closed."] autorelease];
  }
}

+ (IOSObjectArray *)__exceptions_checkStatus {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (NSString *)getEncoding {
  if (encoder_ == nil) {
    return nil;
  }
  return [OrgApacheHarmonyLuniUtilHistoricalNamesUtil getHistoricalNameWithNSString:[((JavaNioCharsetCharset *) nil_chk([((JavaNioCharsetCharsetEncoder *) nil_chk(encoder_)) charset])) name]];
}

- (void)writeWithCharArray:(IOSCharArray *)buf
                   withInt:(int)offset
                   withInt:(int)count {
  [self checkStatus];
  @synchronized (lock_) {
    if (offset < 0 || offset > (int) [((IOSCharArray *) nil_chk(buf)) count] - count || count < 0) {
      @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
    }
    JavaNioCharBuffer *chars = [JavaNioCharBuffer wrapWithCharArray:buf withInt:offset withInt:count];
    [self convertWithJavaNioCharBuffer:chars];
  }
}

+ (IOSObjectArray *)__exceptions_writeWithCharArray_withInt_withInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)convertWithJavaNioCharBuffer:(JavaNioCharBuffer *)chars {
  JavaNioCharsetCoderResult *result = [((JavaNioCharsetCharsetEncoder *) nil_chk(encoder_)) encodeWithJavaNioCharBuffer:chars withJavaNioByteBuffer:bytes_ withBoolean:YES];
  encoderFlush_ = YES;
  while (YES) {
    if ([((JavaNioCharsetCoderResult *) nil_chk(result)) isError]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:[result description]] autorelease];
    }
    else if ([result isOverflow]) {
      [self flush];
      result = [encoder_ encodeWithJavaNioCharBuffer:chars withJavaNioByteBuffer:bytes_ withBoolean:YES];
      continue;
    }
    break;
  }
}

+ (IOSObjectArray *)__exceptions_convertWithJavaNioCharBuffer_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)writeWithInt:(int)oneChar {
  @synchronized (lock_) {
    [self checkStatus];
    JavaNioCharBuffer *chars = [JavaNioCharBuffer wrapWithCharArray:[IOSCharArray arrayWithCharacters:(unichar[]){ (unichar) oneChar } count:1]];
    [self convertWithJavaNioCharBuffer:chars];
  }
}

+ (IOSObjectArray *)__exceptions_writeWithInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)writeWithNSString:(NSString *)str
                  withInt:(int)offset
                  withInt:(int)count {
  @synchronized (lock_) {
    if (count < 0) {
      @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
    }
    if (offset + count > [((NSString *) nil_chk(str)) length] || offset < 0) {
      @throw [[[JavaLangStringIndexOutOfBoundsException alloc] init] autorelease];
    }
    [self checkStatus];
    JavaNioCharBuffer *chars = [JavaNioCharBuffer wrapWithJavaLangCharSequence:str withInt:offset withInt:count + offset];
    [self convertWithJavaNioCharBuffer:chars];
  }
}

+ (IOSObjectArray *)__exceptions_writeWithNSString_withInt_withInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (BOOL)checkError {
  return [((JavaIoOutputStream *) nil_chk(out_)) checkError];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaIoOutputStreamWriter_set_bytes_(self, nil);
  JavaIoOutputStreamWriter_set_encoder_(self, nil);
  JavaIoOutputStreamWriter_set_out_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaIoOutputStreamWriter *)other {
  [super copyAllFieldsTo:other];
  JavaIoOutputStreamWriter_set_bytes_(other, bytes_);
  JavaIoOutputStreamWriter_set_encoder_(other, encoder_);
  other->encoderFlush_ = encoderFlush_;
  JavaIoOutputStreamWriter_set_out_(other, out_);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:out_ name:@"out"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:encoder_ name:@"encoder"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:bytes_ name:@"bytes"]];
  return result;
}

@end
