//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/io/ByteArrayOutputStream.java
//
//  Created by retechretech on 13-9-4.
//

#include "IOSByteArray.h"
#include "IOSCharArray.h"
#include "IOSClass.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/IOException.h"
#include "java/io/OutputStream.h"
#include "java/io/UnsupportedEncodingException.h"
#include "java/lang/Deprecated.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/System.h"

@implementation JavaIoByteArrayOutputStream

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)init {
  if ((self = [super init])) {
    JavaIoByteArrayOutputStream_set_buf_(self, [IOSByteArray arrayWithLength:32]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithInt:(int)size {
  if ((self = [super init])) {
    if (size >= 0) {
      JavaIoByteArrayOutputStream_set_buf_(self, [IOSByteArray arrayWithLength:size]);
    }
    else {
      @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"size must be >= 0"] autorelease];
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)close {
  [super close];
}

+ (IOSObjectArray *)__exceptions_close {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)expandWithInt:(int)i {
  if (count_ + i <= (int) [((IOSByteArray *) nil_chk(buf_)) count]) {
    return;
  }
  IOSByteArray *newbuf = [IOSByteArray arrayWithLength:(count_ + i) * 2];
  [JavaLangSystem arraycopyWithId:buf_ withInt:0 withId:newbuf withInt:0 withInt:count_];
  JavaIoByteArrayOutputStream_set_buf_(self, newbuf);
}

- (void)reset {
  @synchronized(self) {
    {
      count_ = 0;
    }
  }
}

- (int)size {
  return count_;
}

- (IOSByteArray *)toByteArray {
  @synchronized(self) {
    {
      IOSByteArray *newArray = [IOSByteArray arrayWithLength:count_];
      [JavaLangSystem arraycopyWithId:buf_ withInt:0 withId:newArray withInt:0 withInt:count_];
      return newArray;
    }
  }
}

- (NSString *)description {
  return [NSString stringWithBytes:buf_ offset:0 length:count_];
}

- (NSString *)toStringWithInt:(int)hibyte {
  IOSCharArray *newBuf = [IOSCharArray arrayWithLength:[self size]];
  for (int i = 0; i < (int) [newBuf count]; i++) {
    (*[newBuf charRefAtIndex:i]) = (unichar) (((hibyte & (int) 0xff) << 8) | ([((IOSByteArray *) nil_chk(buf_)) byteAtIndex:i] & (int) 0xff));
  }
  return [NSString stringWithCharacters:newBuf];
}

- (NSString *)toStringWithNSString:(NSString *)enc {
  return [NSString stringWithBytes:buf_ offset:0 length:count_ charsetName:enc];
}

+ (IOSObjectArray *)__exceptions_toStringWithNSString_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoUnsupportedEncodingException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)writeWithByteArray:(IOSByteArray *)buffer
                   withInt:(int)offset
                   withInt:(int)len {
  @synchronized(self) {
    {
      if (offset < 0 || offset > (int) [((IOSByteArray *) nil_chk(buffer)) count] || len < 0 || len > (int) [buffer count] - offset) {
        @throw [[[JavaLangIndexOutOfBoundsException alloc] initWithNSString:@"Arguments out of bounds"] autorelease];
      }
      if (len == 0) {
        return;
      }
      [self expandWithInt:len];
      [JavaLangSystem arraycopyWithId:buffer withInt:offset withId:buf_ withInt:self->count_ withInt:len];
      self->count_ += len;
    }
  }
}

- (void)writeWithInt:(int)oneByte {
  @synchronized(self) {
    {
      if (count_ == (int) [((IOSByteArray *) nil_chk(buf_)) count]) {
        [self expandWithInt:1];
      }
      (*[buf_ byteRefAtIndex:count_++]) = (char) oneByte;
    }
  }
}

- (void)writeToWithJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  @synchronized(self) {
    {
      [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:buf_ withInt:0 withInt:count_];
    }
  }
}

+ (IOSObjectArray *)__exceptions_writeToWithJavaIoOutputStream_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaIoByteArrayOutputStream_set_buf_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaIoByteArrayOutputStream *)other {
  [super copyAllFieldsTo:other];
  JavaIoByteArrayOutputStream_set_buf_(other, buf_);
  other->count_ = count_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:buf_ name:@"buf"]];
  return result;
}

+ (IOSObjectArray *)__annotations_toStringWithInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [[[JavaLangDeprecatedImpl alloc] init] autorelease] } count:1 type:[IOSClass classWithProtocol:@protocol(JavaLangAnnotationAnnotation)]];
}

@end
