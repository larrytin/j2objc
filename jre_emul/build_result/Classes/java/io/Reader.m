//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//
//  Created by Larry Tin <dev@goodow.com>
//

#include "IOSCharArray.h"
#include "IOSClass.h"
#include "java/io/IOException.h"
#include "java/io/Reader.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Math.h"
#include "java/lang/NullPointerException.h"
#include "java/nio/CharBuffer.h"

@implementation JavaIoReader

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)init {
  if (self = [super init]) {
    JavaIoReader_set_lock_(self, [[[NSObject alloc] init] autorelease]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithId:(id)lock {
  if (self = [super init]) {
    if (lock == nil) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    JavaIoReader_set_lock_(self, lock);
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)close {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

+ (IOSObjectArray *)__exceptions_close {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)markWithInt:(int)readLimit {
  @throw [[[JavaIoIOException alloc] init] autorelease];
}

+ (IOSObjectArray *)__exceptions_markWithInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (BOOL)markSupported {
  return NO;
}

- (int)read {
  @synchronized (lock_) {
    IOSCharArray *charArray = [IOSCharArray arrayWithLength:1];
    if ([self readWithCharArray:charArray withInt:0 withInt:1] != -1) {
      return IOSCharArray_Get(charArray, 0);
    }
    return -1;
  }
}

+ (IOSObjectArray *)__exceptions_read {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)readWithCharArray:(IOSCharArray *)buf {
  return [self readWithCharArray:buf withInt:0 withInt:(int) [((IOSCharArray *) nil_chk(buf)) count]];
}

+ (IOSObjectArray *)__exceptions_readWithCharArray_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)readWithCharArray:(IOSCharArray *)buf
                 withInt:(int)offset
                 withInt:(int)count {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

+ (IOSObjectArray *)__exceptions_readWithCharArray_withInt_withInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (BOOL)ready {
  return NO;
}

+ (IOSObjectArray *)__exceptions_ready {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)reset {
  @throw [[[JavaIoIOException alloc] init] autorelease];
}

+ (IOSObjectArray *)__exceptions_reset {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (long long int)skipWithLong:(long long int)count {
  if (count < 0) {
    @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
  }
  @synchronized (lock_) {
    long long int skipped = 0;
    int toRead = count < 512 ? (int) count : 512;
    IOSCharArray *charsSkipped = [IOSCharArray arrayWithLength:toRead];
    while (skipped < count) {
      int read = [self readWithCharArray:charsSkipped withInt:0 withInt:toRead];
      if (read == -1) {
        return skipped;
      }
      skipped += read;
      if (read < toRead) {
        return skipped;
      }
      if (count - skipped < toRead) {
        toRead = (int) (count - skipped);
      }
    }
    return skipped;
  }
}

+ (IOSObjectArray *)__exceptions_skipWithLong_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)readWithJavaNioCharBuffer:(JavaNioCharBuffer *)target {
  if (nil == target) {
    @throw [[[JavaLangNullPointerException alloc] init] autorelease];
  }
  int length = [((JavaNioCharBuffer *) nil_chk(target)) sequenceLength];
  IOSCharArray *buf = [IOSCharArray arrayWithLength:length];
  length = [JavaLangMath minWithInt:length withInt:[self readWithCharArray:buf]];
  if (length > 0) {
    [target putWithCharArray:buf withInt:0 withInt:length];
  }
  return length;
}

+ (IOSObjectArray *)__exceptions_readWithJavaNioCharBuffer_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaIoReader_set_lock_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaIoReader *)other {
  [super copyAllFieldsTo:other];
  JavaIoReader_set_lock_(other, lock_);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:lock_ name:@"lock"]];
  return result;
}

@end
