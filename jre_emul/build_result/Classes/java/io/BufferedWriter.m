//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/luni/src/main/java/java/io/BufferedWriter.java
//
//  Created by retechretech on 13-9-4.
//

#include "IOSCharArray.h"
#include "IOSClass.h"
#include "java/io/BufferedWriter.h"
#include "java/io/IOException.h"
#include "java/io/Writer.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/StringIndexOutOfBoundsException.h"
#include "java/lang/System.h"

@implementation JavaIoBufferedWriter

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithJavaIoWriter:(JavaIoWriter *)outArg {
  if ((self = [super initWithId:outArg])) {
    JavaIoBufferedWriter_set_lineSeparator_(self, @"\n");
    JavaIoBufferedWriter_set_out_(self, outArg);
    JavaIoBufferedWriter_set_buf_(self, [IOSCharArray arrayWithLength:8192]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaIoWriter:(JavaIoWriter *)outArg
                   withInt:(int)size {
  if ((self = [super initWithId:outArg])) {
    JavaIoBufferedWriter_set_lineSeparator_(self, @"\n");
    if (size <= 0) {
      @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"size must be > 0"] autorelease];
    }
    JavaIoBufferedWriter_set_out_(self, outArg);
    JavaIoBufferedWriter_set_buf_(self, [IOSCharArray arrayWithLength:size]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)close {
  @synchronized (lock_) {
    if ([self isClosed]) {
      return;
    }
    JavaIoIOException *thrown = nil;
    @try {
      [self flushInternal];
    }
    @catch (JavaIoIOException *e) {
      thrown = e;
    }
    JavaIoBufferedWriter_set_buf_(self, nil);
    @try {
      [((JavaIoWriter *) nil_chk(out_)) close];
    }
    @catch (JavaIoIOException *e) {
      if (thrown == nil) {
        thrown = e;
      }
    }
    JavaIoBufferedWriter_set_out_(self, nil);
    if (thrown != nil) {
      @throw thrown;
    }
  }
}

+ (IOSObjectArray *)__exceptions_close {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)flush {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"writer is closed"] autorelease];
    }
    [self flushInternal];
    [((JavaIoWriter *) nil_chk(out_)) flush];
  }
}

+ (IOSObjectArray *)__exceptions_flush {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)flushInternal {
  if (pos_ > 0) {
    [((JavaIoWriter *) nil_chk(out_)) writeWithCharArray:buf_ withInt:0 withInt:pos_];
  }
  pos_ = 0;
}

+ (IOSObjectArray *)__exceptions_flushInternal {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (BOOL)isClosed {
  return out_ == nil;
}

- (void)newLine {
  [self writeWithNSString:lineSeparator_ withInt:0 withInt:[((NSString *) nil_chk(lineSeparator_)) length]];
}

+ (IOSObjectArray *)__exceptions_newLine {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)writeWithCharArray:(IOSCharArray *)cbuf
                   withInt:(int)offset
                   withInt:(int)count {
  if (cbuf == nil) {
    @throw [[[JavaLangNullPointerException alloc] init] autorelease];
  }
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"writer is closed"] autorelease];
    }
    if (offset < 0 || offset > (int) [((IOSCharArray *) nil_chk(cbuf)) count] - count || count < 0) {
      @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
    }
    if (pos_ == 0 && count >= (int) [((IOSCharArray *) nil_chk(self->buf_)) count]) {
      [((JavaIoWriter *) nil_chk(out_)) writeWithCharArray:cbuf withInt:offset withInt:count];
      return;
    }
    int available = (int) [((IOSCharArray *) nil_chk(self->buf_)) count] - pos_;
    if (count < available) {
      available = count;
    }
    if (available > 0) {
      [JavaLangSystem arraycopyWithId:cbuf withInt:offset withId:self->buf_ withInt:pos_ withInt:available];
      pos_ += available;
    }
    if (pos_ == (int) [self->buf_ count]) {
      [((JavaIoWriter *) nil_chk(out_)) writeWithCharArray:self->buf_ withInt:0 withInt:(int) [self->buf_ count]];
      pos_ = 0;
      if (count > available) {
        offset += available;
        available = count - available;
        if (available >= (int) [self->buf_ count]) {
          [out_ writeWithCharArray:cbuf withInt:offset withInt:available];
          return;
        }
        [JavaLangSystem arraycopyWithId:cbuf withInt:offset withId:self->buf_ withInt:pos_ withInt:available];
        pos_ += available;
      }
    }
  }
}

+ (IOSObjectArray *)__exceptions_writeWithCharArray_withInt_withInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)writeWithInt:(int)oneChar {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"writer is closed"] autorelease];
    }
    if (pos_ >= (int) [((IOSCharArray *) nil_chk(buf_)) count]) {
      [((JavaIoWriter *) nil_chk(out_)) writeWithCharArray:buf_ withInt:0 withInt:(int) [buf_ count]];
      pos_ = 0;
    }
    (*[buf_ charRefAtIndex:pos_++]) = (unichar) oneChar;
  }
}

+ (IOSObjectArray *)__exceptions_writeWithInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)writeWithNSString:(NSString *)str
                  withInt:(int)offset
                  withInt:(int)count {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"writer is closed"] autorelease];
    }
    if (count <= 0) {
      return;
    }
    if (str == nil) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    if (offset > [((NSString *) nil_chk(str)) length] - count || offset < 0) {
      @throw [[[JavaLangStringIndexOutOfBoundsException alloc] init] autorelease];
    }
    if (pos_ == 0 && count >= (int) [((IOSCharArray *) nil_chk(buf_)) count]) {
      IOSCharArray *chars = [IOSCharArray arrayWithLength:count];
      [str getChars:offset sourceEnd:offset + count destination:chars destinationBegin:0];
      [((JavaIoWriter *) nil_chk(out_)) writeWithCharArray:chars withInt:0 withInt:count];
      return;
    }
    int available = (int) [((IOSCharArray *) nil_chk(buf_)) count] - pos_;
    if (count < available) {
      available = count;
    }
    if (available > 0) {
      [str getChars:offset sourceEnd:offset + available destination:buf_ destinationBegin:pos_];
      pos_ += available;
    }
    if (pos_ == (int) [buf_ count]) {
      [((JavaIoWriter *) nil_chk(out_)) writeWithCharArray:self->buf_ withInt:0 withInt:(int) [self->buf_ count]];
      pos_ = 0;
      if (count > available) {
        offset += available;
        available = count - available;
        if (available >= (int) [buf_ count]) {
          IOSCharArray *chars = [IOSCharArray arrayWithLength:count];
          [str getChars:offset sourceEnd:offset + available destination:chars destinationBegin:0];
          [out_ writeWithCharArray:chars withInt:0 withInt:available];
          return;
        }
        [str getChars:offset sourceEnd:offset + available destination:buf_ destinationBegin:pos_];
        pos_ += available;
      }
    }
  }
}

+ (IOSObjectArray *)__exceptions_writeWithNSString_withInt_withInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaIoBufferedWriter_set_lineSeparator_(self, nil);
  JavaIoBufferedWriter_set_buf_(self, nil);
  JavaIoBufferedWriter_set_out_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaIoBufferedWriter *)other {
  [super copyAllFieldsTo:other];
  JavaIoBufferedWriter_set_buf_(other, buf_);
  JavaIoBufferedWriter_set_lineSeparator_(other, lineSeparator_);
  JavaIoBufferedWriter_set_out_(other, out_);
  other->pos_ = pos_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:out_ name:@"out"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:buf_ name:@"buf"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:lineSeparator_ name:@"lineSeparator"]];
  return result;
}

@end
