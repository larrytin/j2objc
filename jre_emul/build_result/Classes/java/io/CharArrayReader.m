//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//
//  Created by Larry Tin <dev@goodow.com>
//

#include "IOSCharArray.h"
#include "IOSClass.h"
#include "java/io/CharArrayReader.h"
#include "java/io/IOException.h"
#include "java/lang/ArrayIndexOutOfBoundsException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/System.h"

@implementation JavaIoCharArrayReader

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithCharArray:(IOSCharArray *)buf {
  if (self = [super init]) {
    markedPos_ = -1;
    JavaIoCharArrayReader_set_buf_(self, buf);
    self->count_ = (int) [((IOSCharArray *) nil_chk(buf)) count];
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithCharArray:(IOSCharArray *)buf
                withInt:(int)offset
                withInt:(int)length {
  if (self = [super init]) {
    markedPos_ = -1;
    if (offset < 0 || offset > (int) [((IOSCharArray *) nil_chk(buf)) count] || length < 0 || offset + length < 0) {
      @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
    }
    JavaIoCharArrayReader_set_buf_(self, buf);
    self->pos_ = offset;
    self->markedPos_ = offset;
    int bufferLength = (int) [((IOSCharArray *) nil_chk(buf)) count];
    self->count_ = offset + length < bufferLength ? length : bufferLength;
    JreMemDebugAdd(self);
  }
  return self;
}

- (void)close {
  @synchronized (lock_) {
    if ([self isOpen]) {
      JavaIoCharArrayReader_set_buf_(self, nil);
    }
  }
}

- (BOOL)isOpen {
  return buf_ != nil;
}

- (BOOL)isClosed {
  return buf_ == nil;
}

- (void)markWithInt:(int)readLimit {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"CharArrayReader is closed."] autorelease];
    }
    markedPos_ = pos_;
  }
}

+ (IOSObjectArray *)__exceptions_markWithInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (BOOL)markSupported {
  return YES;
}

- (int)read {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"CharArrayReader is closed."] autorelease];
    }
    if (pos_ == count_) {
      return -1;
    }
    return IOSCharArray_Get(nil_chk(buf_), pos_++);
  }
}

+ (IOSObjectArray *)__exceptions_read {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (int)readWithCharArray:(IOSCharArray *)buffer
                 withInt:(int)offset
                 withInt:(int)len {
  if (offset < 0 || offset > (int) [((IOSCharArray *) nil_chk(buffer)) count]) {
    @throw [[[JavaLangArrayIndexOutOfBoundsException alloc] initWithNSString:[NSString stringWithFormat:@"Offset out of bounds: %d", offset]] autorelease];
  }
  if (len < 0 || len > (int) [((IOSCharArray *) nil_chk(buffer)) count] - offset) {
    @throw [[[JavaLangArrayIndexOutOfBoundsException alloc] initWithNSString:[NSString stringWithFormat:@"Length out of bounds: %d", len]] autorelease];
  }
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"CharArrayReader is closed."] autorelease];
    }
    if (pos_ < self->count_) {
      int bytesRead = pos_ + len > self->count_ ? self->count_ - pos_ : len;
      [JavaLangSystem arraycopyWithId:self->buf_ withInt:pos_ withId:buffer withInt:offset withInt:bytesRead];
      pos_ += bytesRead;
      return bytesRead;
    }
    return -1;
  }
}

+ (IOSObjectArray *)__exceptions_readWithCharArray_withInt_withInt_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (BOOL)ready {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"CharArrayReader is closed."] autorelease];
    }
    return pos_ != count_;
  }
}

+ (IOSObjectArray *)__exceptions_ready {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)reset {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"CharArrayReader is closed."] autorelease];
    }
    pos_ = markedPos_ != -1 ? markedPos_ : 0;
  }
}

+ (IOSObjectArray *)__exceptions_reset {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (long long int)skipWithLong:(long long int)n {
  @synchronized (lock_) {
    if ([self isClosed]) {
      @throw [[[JavaIoIOException alloc] initWithNSString:@"CharArrayReader is closed."] autorelease];
    }
    if (n <= 0) {
      return 0;
    }
    long long int skipped = 0;
    if (n < self->count_ - pos_) {
      pos_ = pos_ + (int) n;
      skipped = n;
    }
    else {
      skipped = self->count_ - pos_;
      pos_ = self->count_;
    }
    return skipped;
  }
}

+ (IOSObjectArray *)__exceptions_skipWithLong_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoIOException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaIoCharArrayReader_set_buf_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaIoCharArrayReader *)other {
  [super copyAllFieldsTo:other];
  JavaIoCharArrayReader_set_buf_(other, buf_);
  other->count_ = count_;
  other->markedPos_ = markedPos_;
  other->pos_ = pos_;
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:buf_ name:@"buf"]];
  return result;
}

@end
