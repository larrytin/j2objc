//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: Classes/java/lang/Math.java
//
//  Created by retechretech on 13-9-25.
//

#include "java/lang/Double.h"
#include "java/lang/Float.h"
#include "java/lang/Math.h"
#include "java/lang/StrictMath.h"
#include "java/util/Random.h"

@implementation JavaLangMath

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaLangMath_random__ name:@"JavaLangMath_random__"]];
  return result;
}

static JavaUtilRandom * JavaLangMath_random__;

+ (double)E {
  return JavaLangMath_E;
}

+ (double)PI {
  return JavaLangMath_PI;
}

+ (JavaUtilRandom *)random_ {
  return JavaLangMath_random__;
}

+ (void)setRandom_:(JavaUtilRandom *)random_ {
  JreOperatorRetainedAssign(&JavaLangMath_random__, nil, random_);
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

+ (double)absWithDouble:(double)d {
  long long int bits = [JavaLangDouble doubleToLongBitsWithDouble:d];
  bits &= (long long) 0x7fffffffffffffffLL;
  return [JavaLangDouble longBitsToDoubleWithLong:bits];
}

+ (float)absWithFloat:(float)f {
  int bits = [JavaLangFloat floatToIntBitsWithFloat:f];
  bits &= (int) 0x7fffffff;
  return [JavaLangFloat intBitsToFloatWithInt:bits];
}

+ (int)absWithInt:(int)i {
  return i >= 0 ? i : -i;
}

+ (long long int)absWithLong:(long long int)l {
  return l >= 0 ? l : -l;
}

+ (double)acosWithDouble:(double)d {
  return acos(d);
}

+ (double)asinWithDouble:(double)d {
  return asin(d);
}

+ (double)atanWithDouble:(double)d {
  return atan(d);
}

+ (double)atan2WithDouble:(double)x
               withDouble:(double)y {
  return atan2(x, y);
}

+ (double)cbrtWithDouble:(double)d {
  return cbrt(d);
}

+ (double)ceilWithDouble:(double)d {
  return ceil(d);
}

+ (double)cosWithDouble:(double)d {
  return cos(d);
}

+ (double)coshWithDouble:(double)d {
  return cosh(d);
}

+ (double)expWithDouble:(double)d {
  return exp(d);
}

+ (double)expm1WithDouble:(double)d {
  return expm1(d);
}

+ (double)floorWithDouble:(double)d {
  return floor(d);
}

+ (double)hypotWithDouble:(double)x
               withDouble:(double)y {
  return hypot(x, y);
}

+ (double)IEEEremainderWithDouble:(double)x
                       withDouble:(double)y {
  // According to the Mac OS X math.h online man page, their routines are
  // all IEEE Standard 754 compliant.
  return remainder(x, y);
}

+ (double)logWithDouble:(double)d {
  return log(d);
}

+ (double)log10WithDouble:(double)d {
  return log10(d);
}

+ (double)log1pWithDouble:(double)d {
  return log1p(d);
}

+ (double)maxWithDouble:(double)d1
             withDouble:(double)d2 {
  return fmax(d1, d2);
}

+ (float)maxWithFloat:(float)f1
            withFloat:(float)f2 {
  return fmaxf(f1, f2);
}

+ (int)maxWithInt:(int)i1
          withInt:(int)i2 {
  return i1 > i2 ? i1 : i2;
}

+ (long long int)maxWithLong:(long long int)l1
                    withLong:(long long int)l2 {
  return l1 > l2 ? l1 : l2;
}

+ (double)minWithDouble:(double)d1
             withDouble:(double)d2 {
  return fmin(d1, d2);
}

+ (float)minWithFloat:(float)f1
            withFloat:(float)f2 {
  return fminf(f1, f2);
}

+ (int)minWithInt:(int)i1
          withInt:(int)i2 {
  return i1 < i2 ? i1 : i2;
}

+ (long long int)minWithLong:(long long int)l1
                    withLong:(long long int)l2 {
  return l1 < l2 ? l1 : l2;
}

+ (double)powWithDouble:(double)x
             withDouble:(double)y {
  return pow(x, y);
}

+ (double)rintWithDouble:(double)d {
  return rint(d);
}

+ (long long int)roundWithDouble:(double)d {
  if (d != d) {
    return 0LL;
  }
  return (long long int) [JavaLangMath floorWithDouble:d + 0.5];
}

+ (int)roundWithFloat:(float)f {
  if (f != f) {
    return 0;
  }
  return (int) [JavaLangMath floorWithDouble:f + 0.5f];
}

+ (double)signumWithDouble:(double)d {
  return [JavaLangStrictMath signumWithDouble:d];
}

+ (float)signumWithFloat:(float)f {
  return [JavaLangStrictMath signumWithFloat:f];
}

+ (double)sinWithDouble:(double)d {
  return sin(d);
}

+ (double)sinhWithDouble:(double)d {
  return sinh(d);
}

+ (double)sqrtWithDouble:(double)d {
  return sqrt(d);
}

+ (double)tanWithDouble:(double)d {
  return tan(d);
}

+ (double)tanhWithDouble:(double)d {
  return tanh(d);
}

+ (double)random {
  if (JavaLangMath_random__ == nil) {
    JreOperatorRetainedAssign(&JavaLangMath_random__, nil, [[[JavaUtilRandom alloc] init] autorelease]);
  }
  return [((JavaUtilRandom *) nil_chk(JavaLangMath_random__)) nextDouble];
}

+ (double)toRadiansWithDouble:(double)angdeg {
  return angdeg / 180.0 * JavaLangMath_PI;
}

+ (double)toDegreesWithDouble:(double)angrad {
  return angrad * 180.0 / JavaLangMath_PI;
}

+ (double)ulpWithDouble:(double)d {
  if ([JavaLangDouble isInfiniteWithDouble:d]) {
    return JavaLangDouble_POSITIVE_INFINITY;
  }
  else if (d == JavaLangDouble_MAX_VALUE || d == -JavaLangDouble_MAX_VALUE) {
    return [JavaLangMath powWithDouble:2 withDouble:971];
  }
  d = [JavaLangMath absWithDouble:d];
  return [JavaLangMath nextafterWithDouble:d withDouble:JavaLangDouble_MAX_VALUE] - d;
}

+ (float)ulpWithFloat:(float)f {
  if ([JavaLangFloat isNaNWithFloat:f]) {
    return JavaLangFloat_NaN;
  }
  else if ([JavaLangFloat isInfiniteWithFloat:f]) {
    return JavaLangFloat_POSITIVE_INFINITY;
  }
  else if (f == JavaLangFloat_MAX_VALUE || f == -JavaLangFloat_MAX_VALUE) {
    return (float) [JavaLangMath powWithDouble:2 withDouble:104];
  }
  f = [JavaLangMath absWithFloat:f];
  return [JavaLangMath nextafterfWithFloat:f withFloat:JavaLangFloat_MAX_VALUE] - f;
}

+ (double)copySignWithDouble:(double)magnitude
                  withDouble:(double)sign {
  long long int magnitudeBits = [JavaLangDouble doubleToRawLongBitsWithDouble:magnitude];
  long long int signBits = [JavaLangDouble doubleToRawLongBitsWithDouble:sign];
  magnitudeBits = (magnitudeBits & ~JavaLangDouble_SIGN_MASK) | (signBits & JavaLangDouble_SIGN_MASK);
  return [JavaLangDouble longBitsToDoubleWithLong:magnitudeBits];
}

+ (float)copySignWithFloat:(float)magnitude
                 withFloat:(float)sign {
  int magnitudeBits = [JavaLangFloat floatToRawIntBitsWithFloat:magnitude];
  int signBits = [JavaLangFloat floatToRawIntBitsWithFloat:sign];
  magnitudeBits = (magnitudeBits & ~JavaLangFloat_SIGN_MASK) | (signBits & JavaLangFloat_SIGN_MASK);
  return [JavaLangFloat intBitsToFloatWithInt:magnitudeBits];
}

+ (int)getExponentWithFloat:(float)f {
  int bits = [JavaLangFloat floatToRawIntBitsWithFloat:f];
  bits = (bits & JavaLangFloat_EXPONENT_MASK) >> JavaLangFloat_MANTISSA_BITS;
  return bits - JavaLangFloat_EXPONENT_BIAS;
}

+ (int)getExponentWithDouble:(double)d {
  long long int bits = [JavaLangDouble doubleToRawLongBitsWithDouble:d];
  bits = (bits & JavaLangDouble_EXPONENT_MASK) >> JavaLangDouble_MANTISSA_BITS;
  return (int) bits - JavaLangDouble_EXPONENT_BIAS;
}

+ (double)nextAfterWithDouble:(double)start
                   withDouble:(double)direction {
  if (start == 0 && direction == 0) {
    return direction;
  }
  return [JavaLangMath nextafterWithDouble:start withDouble:direction];
}

+ (float)nextAfterWithFloat:(float)start
                 withDouble:(double)direction {
  if ([JavaLangFloat isNaNWithFloat:start] || [JavaLangDouble isNaNWithDouble:direction]) {
    return JavaLangFloat_NaN;
  }
  if (start == 0 && direction == 0) {
    return (float) direction;
  }
  if ((start == JavaLangFloat_MIN_VALUE && direction < start) || (start == -JavaLangFloat_MIN_VALUE && direction > start)) {
    return (start > 0 ? 0.0f : -0.0f);
  }
  if ([JavaLangFloat isInfiniteWithFloat:start] && (direction != start)) {
    return (start > 0 ? JavaLangFloat_MAX_VALUE : -JavaLangFloat_MAX_VALUE);
  }
  if ((start == JavaLangFloat_MAX_VALUE && direction > start) || (start == -JavaLangFloat_MAX_VALUE && direction < start)) {
    return (start > 0 ? JavaLangFloat_POSITIVE_INFINITY : JavaLangFloat_NEGATIVE_INFINITY);
  }
  if (direction > start) {
    if (start > 0) {
      return [JavaLangFloat intBitsToFloatWithInt:[JavaLangFloat floatToIntBitsWithFloat:start] + 1];
    }
    if (start < 0) {
      return [JavaLangFloat intBitsToFloatWithInt:[JavaLangFloat floatToIntBitsWithFloat:start] - 1];
    }
    return +JavaLangFloat_MIN_VALUE;
  }
  if (direction < start) {
    if (start > 0) {
      return [JavaLangFloat intBitsToFloatWithInt:[JavaLangFloat floatToIntBitsWithFloat:start] - 1];
    }
    if (start < 0) {
      return [JavaLangFloat intBitsToFloatWithInt:[JavaLangFloat floatToIntBitsWithFloat:start] + 1];
    }
    return -JavaLangFloat_MIN_VALUE;
  }
  return (float) direction;
}

+ (double)nextUpWithDouble:(double)d {
  if ([JavaLangDouble isNaNWithDouble:d]) {
    return JavaLangDouble_NaN;
  }
  if (d == JavaLangDouble_POSITIVE_INFINITY) {
    return JavaLangDouble_POSITIVE_INFINITY;
  }
  if (d == 0) {
    return JavaLangDouble_MIN_VALUE;
  }
  else if (d > 0) {
    return [JavaLangDouble longBitsToDoubleWithLong:[JavaLangDouble doubleToLongBitsWithDouble:d] + 1];
  }
  else {
    return [JavaLangDouble longBitsToDoubleWithLong:[JavaLangDouble doubleToLongBitsWithDouble:d] - 1];
  }
}

+ (float)nextUpWithFloat:(float)f {
  if ([JavaLangFloat isNaNWithFloat:f]) {
    return JavaLangFloat_NaN;
  }
  if (f == JavaLangFloat_POSITIVE_INFINITY) {
    return JavaLangFloat_POSITIVE_INFINITY;
  }
  if (f == 0) {
    return JavaLangFloat_MIN_VALUE;
  }
  else if (f > 0) {
    return [JavaLangFloat intBitsToFloatWithInt:[JavaLangFloat floatToIntBitsWithFloat:f] + 1];
  }
  else {
    return [JavaLangFloat intBitsToFloatWithInt:[JavaLangFloat floatToIntBitsWithFloat:f] - 1];
  }
}

+ (double)nextafterWithDouble:(double)x
                   withDouble:(double)y {
  return nextafter(x, y);
}

+ (float)nextafterfWithFloat:(float)x
                   withFloat:(float)y {
  return nextafterf(x, y);
}

@end
