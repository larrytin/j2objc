//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//
//  Created by Larry Tin <dev@goodow.com>
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "java/io/PrintStream.h"
#include "java/lang/IllegalThreadStateException.h"
#include "java/lang/System.h"
#include "java/lang/Thread.h"
#include "java/lang/ThreadDeath.h"
#include "java/lang/ThreadGroup.h"
#include "java/lang/Throwable.h"

@implementation JavaLangThreadGroup

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)init {
  if (self = [super init]) {
    maxPriority_ = JavaLangThread_MAX_PRIORITY;
    JavaLangThreadGroup_set_childrenThreads_(self, [IOSObjectArray arrayWithLength:5 type:[IOSClass classWithClass:[JavaLangThread class]]]);
    JavaLangThreadGroup_set_childrenGroups_(self, [IOSObjectArray arrayWithLength:3 type:[IOSClass classWithClass:[JavaLangThreadGroup class]]]);
    JavaLangThreadGroup_set_childrenGroupsLock_(self, [[[JavaLangThreadGroup_ChildrenGroupsLock alloc] initWithJavaLangThreadGroup:self] autorelease]);
    JavaLangThreadGroup_set_childrenThreadsLock_(self, [[[JavaLangThreadGroup_ChildrenThreadsLock alloc] initWithJavaLangThreadGroup:self] autorelease]);
    JavaLangThreadGroup_set_name_(self, @"system");
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithNSString:(NSString *)name {
  return JreMemDebugAdd([self initJavaLangThreadGroupWithJavaLangThreadGroup:[((JavaLangThread *) nil_chk([JavaLangThread currentThread])) getThreadGroup] withNSString:name]);
}

- (id)initJavaLangThreadGroupWithJavaLangThreadGroup:(JavaLangThreadGroup *)parent
                                        withNSString:(NSString *)name {
  if (self = [super init]) {
    maxPriority_ = JavaLangThread_MAX_PRIORITY;
    JavaLangThreadGroup_set_childrenThreads_(self, [IOSObjectArray arrayWithLength:5 type:[IOSClass classWithClass:[JavaLangThread class]]]);
    JavaLangThreadGroup_set_childrenGroups_(self, [IOSObjectArray arrayWithLength:3 type:[IOSClass classWithClass:[JavaLangThreadGroup class]]]);
    JavaLangThreadGroup_set_childrenGroupsLock_(self, [[[JavaLangThreadGroup_ChildrenGroupsLock alloc] initWithJavaLangThreadGroup:self] autorelease]);
    JavaLangThreadGroup_set_childrenThreadsLock_(self, [[[JavaLangThreadGroup_ChildrenThreadsLock alloc] initWithJavaLangThreadGroup:self] autorelease]);
    JavaLangThreadGroup_set_name_(self, name);
    [self setParentWithJavaLangThreadGroup:parent];
    if (parent != nil) {
      [self setMaxPriorityWithInt:[parent getMaxPriority]];
    }
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaLangThreadGroup:(JavaLangThreadGroup *)parent
                     withNSString:(NSString *)name {
  return [self initJavaLangThreadGroupWithJavaLangThreadGroup:parent withNSString:name];
}

- (id)initWithJavaLangThreadGroup:(JavaLangThreadGroup *)parent {
  if (self = [super init]) {
    maxPriority_ = JavaLangThread_MAX_PRIORITY;
    JavaLangThreadGroup_set_childrenThreads_(self, [IOSObjectArray arrayWithLength:5 type:[IOSClass classWithClass:[JavaLangThread class]]]);
    JavaLangThreadGroup_set_childrenGroups_(self, [IOSObjectArray arrayWithLength:3 type:[IOSClass classWithClass:[JavaLangThreadGroup class]]]);
    JavaLangThreadGroup_set_childrenGroupsLock_(self, [[[JavaLangThreadGroup_ChildrenGroupsLock alloc] initWithJavaLangThreadGroup:self] autorelease]);
    JavaLangThreadGroup_set_childrenThreadsLock_(self, [[[JavaLangThreadGroup_ChildrenThreadsLock alloc] initWithJavaLangThreadGroup:self] autorelease]);
    JavaLangThreadGroup_set_name_(self, @"main");
    [self setParentWithJavaLangThreadGroup:parent];
    JreMemDebugAdd(self);
  }
  return self;
}

- (int)activeCount {
  int count = numThreads_;
  @synchronized (self->childrenGroupsLock_) {
    for (int i = 0; i < numGroups_; i++) {
      count += [((JavaLangThreadGroup *) nil_chk(IOSObjectArray_Get(nil_chk(self->childrenGroups_), i))) activeCount];
    }
  }
  return count;
}

- (int)activeGroupCount {
  int count = 0;
  @synchronized (self->childrenGroupsLock_) {
    for (int i = 0; i < numGroups_; i++) {
      count += 1 + [((JavaLangThreadGroup *) nil_chk(IOSObjectArray_Get(nil_chk(self->childrenGroups_), i))) activeGroupCount];
    }
  }
  return count;
}

- (void)addWithJavaLangThread:(JavaLangThread *)thread {
  @synchronized (self->childrenThreadsLock_) {
    if (!isDestroyed__) {
      if ((int) [((IOSObjectArray *) nil_chk(childrenThreads_)) count] == numThreads_) {
        IOSObjectArray *newThreads = [IOSObjectArray arrayWithLength:(int) [childrenThreads_ count] * 2 type:[IOSClass classWithClass:[JavaLangThread class]]];
        [JavaLangSystem arraycopyWithId:childrenThreads_ withInt:0 withId:newThreads withInt:0 withInt:numThreads_];
        IOSObjectArray_Set(newThreads, numThreads_++, thread);
        JavaLangThreadGroup_set_childrenThreads_(self, newThreads);
      }
      else {
        IOSObjectArray_Set(childrenThreads_, numThreads_++, thread);
      }
    }
    else {
      @throw [[[JavaLangIllegalThreadStateException alloc] init] autorelease];
    }
  }
}

+ (IOSObjectArray *)__exceptions_addWithJavaLangThread_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaLangIllegalThreadStateException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)addWithJavaLangThreadGroup:(JavaLangThreadGroup *)g {
  @synchronized (self->childrenGroupsLock_) {
    if (!isDestroyed__) {
      if ((int) [((IOSObjectArray *) nil_chk(childrenGroups_)) count] == numGroups_) {
        IOSObjectArray *newGroups = [IOSObjectArray arrayWithLength:(int) [childrenGroups_ count] * 2 type:[IOSClass classWithClass:[JavaLangThreadGroup class]]];
        [JavaLangSystem arraycopyWithId:childrenGroups_ withInt:0 withId:newGroups withInt:0 withInt:numGroups_];
        IOSObjectArray_Set(newGroups, numGroups_++, g);
        JavaLangThreadGroup_set_childrenGroups_(self, newGroups);
      }
      else {
        IOSObjectArray_Set(childrenGroups_, numGroups_++, g);
      }
    }
    else {
      @throw [[[JavaLangIllegalThreadStateException alloc] init] autorelease];
    }
  }
}

+ (IOSObjectArray *)__exceptions_addWithJavaLangThreadGroup_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaLangIllegalThreadStateException getClass] } count:1 type:[IOSClass getClass]];
}

- (void)checkAccess {
}

- (void)destroy {
  [self checkAccess];
  @synchronized (self->childrenThreadsLock_) {
    @synchronized (self->childrenGroupsLock_) {
      int toDestroy = numGroups_;
      for (int i = 0; i < toDestroy; i++) {
        [((JavaLangThreadGroup *) nil_chk(IOSObjectArray_Get(nil_chk(self->childrenGroups_), 0))) destroy];
      }
      if (parent_ != nil) {
        [parent_ removeWithJavaLangThreadGroup:self];
      }
      self->isDestroyed__ = YES;
    }
  }
}

- (int)enumerateWithJavaLangThreadArray:(IOSObjectArray *)threads {
  return [self enumerateWithJavaLangThreadArray:threads withBoolean:YES];
}

- (int)enumerateWithJavaLangThreadArray:(IOSObjectArray *)threads
                            withBoolean:(BOOL)recurse {
  return [self enumerateGenericWithNSObjectArray:threads withBoolean:recurse withInt:0 withBoolean:YES];
}

- (int)enumerateWithJavaLangThreadGroupArray:(IOSObjectArray *)groups {
  return [self enumerateWithJavaLangThreadGroupArray:groups withBoolean:YES];
}

- (int)enumerateWithJavaLangThreadGroupArray:(IOSObjectArray *)groups
                                 withBoolean:(BOOL)recurse {
  return [self enumerateGenericWithNSObjectArray:groups withBoolean:recurse withInt:0 withBoolean:NO];
}

- (int)enumerateGenericWithNSObjectArray:(IOSObjectArray *)enumeration
                             withBoolean:(BOOL)recurse
                                 withInt:(int)enumerationIndex
                             withBoolean:(BOOL)enumeratingThreads {
  [self checkAccess];
  IOSObjectArray *immediateCollection = enumeratingThreads ? (IOSObjectArray *) check_class_cast(childrenThreads_, [IOSObjectArray class]) : (IOSObjectArray *) check_class_cast(childrenGroups_, [IOSObjectArray class]);
  id syncLock = enumeratingThreads ? childrenThreadsLock_ : childrenGroupsLock_;
  @synchronized (syncLock) {
    for (int i = enumeratingThreads ? numThreads_ : numGroups_; --i >= 0; ) {
      if (!enumeratingThreads || [((JavaLangThread *) nil_chk(IOSObjectArray_Get(immediateCollection, i))) isAlive]) {
        if (enumerationIndex >= (int) [((IOSObjectArray *) nil_chk(enumeration)) count]) {
          return enumerationIndex;
        }
        IOSObjectArray_Set(enumeration, enumerationIndex++, IOSObjectArray_Get(immediateCollection, i));
      }
    }
  }
  if (recurse) {
    @synchronized (self->childrenGroupsLock_) {
      for (int i = 0; i < numGroups_; i++) {
        if (enumerationIndex >= (int) [((IOSObjectArray *) nil_chk(enumeration)) count]) {
          return enumerationIndex;
        }
        enumerationIndex = [((JavaLangThreadGroup *) nil_chk(IOSObjectArray_Get(nil_chk(childrenGroups_), i))) enumerateGenericWithNSObjectArray:enumeration withBoolean:recurse withInt:enumerationIndex withBoolean:enumeratingThreads];
      }
    }
  }
  return enumerationIndex;
}

- (int)getMaxPriority {
  return maxPriority_;
}

- (NSString *)getName {
  return name_;
}

- (JavaLangThreadGroup *)getParent {
  if (parent_ != nil) {
    [parent_ checkAccess];
  }
  return parent_;
}

- (BOOL)isDestroyed {
  return isDestroyed__;
}

- (void)list {
  [self listWithInt:0];
}

- (void)listWithInt:(int)levels {
  for (int i = 0; i < levels; i++) {
    [((JavaIoPrintStream *) nil_chk([JavaLangSystem out])) printWithNSString:@"    "];
  }
  [((JavaIoPrintStream *) nil_chk([JavaLangSystem out])) printlnWithNSString:[self description]];
  @synchronized (self->childrenThreadsLock_) {
    for (int i = 0; i < numThreads_; i++) {
      for (int j = 0; j <= levels; j++) {
        [[JavaLangSystem out] printWithNSString:@"    "];
      }
      [[JavaLangSystem out] printlnWithId:IOSObjectArray_Get(nil_chk(self->childrenThreads_), i)];
    }
  }
  @synchronized (self->childrenGroupsLock_) {
    for (int i = 0; i < numGroups_; i++) {
      [((JavaLangThreadGroup *) nil_chk(IOSObjectArray_Get(nil_chk(self->childrenGroups_), i))) listWithInt:levels + 1];
    }
  }
}

- (BOOL)parentOfWithJavaLangThreadGroup:(JavaLangThreadGroup *)g {
  while (g != nil) {
    if (self == g) {
      return YES;
    }
    g = ((JavaLangThreadGroup *) nil_chk(g))->parent_;
  }
  return NO;
}

- (void)removeWithJavaLangThread:(JavaLangThread *)thread {
  @synchronized (self->childrenThreadsLock_) {
    for (int i = 0; i < numThreads_; i++) {
      if ([((JavaLangThread *) nil_chk(IOSObjectArray_Get(nil_chk(childrenThreads_), i))) isEqual:thread]) {
        numThreads_--;
        [JavaLangSystem arraycopyWithId:childrenThreads_ withInt:i + 1 withId:childrenThreads_ withInt:i withInt:numThreads_ - i];
        IOSObjectArray_Set(childrenThreads_, numThreads_, nil);
        break;
      }
    }
  }
}

- (void)removeWithJavaLangThreadGroup:(JavaLangThreadGroup *)g {
  @synchronized (self->childrenGroupsLock_) {
    for (int i = 0; i < numGroups_; i++) {
      if ([((JavaLangThreadGroup *) nil_chk(IOSObjectArray_Get(nil_chk(childrenGroups_), i))) isEqual:g]) {
        numGroups_--;
        [JavaLangSystem arraycopyWithId:childrenGroups_ withInt:i + 1 withId:childrenGroups_ withInt:i withInt:numGroups_ - i];
        IOSObjectArray_Set(childrenGroups_, numGroups_, nil);
        break;
      }
    }
  }
}

- (void)setMaxPriorityWithInt:(int)newMax {
  [self checkAccess];
  if (newMax <= self->maxPriority_) {
    if (newMax < JavaLangThread_MIN_PRIORITY) {
      newMax = JavaLangThread_MIN_PRIORITY;
    }
    int parentPriority = parent_ == nil ? newMax : [parent_ getMaxPriority];
    self->maxPriority_ = parentPriority <= newMax ? parentPriority : newMax;
    @synchronized (self->childrenGroupsLock_) {
      for (int i = 0; i < numGroups_; i++) {
        [((JavaLangThreadGroup *) nil_chk(IOSObjectArray_Get(nil_chk(self->childrenGroups_), i))) setMaxPriorityWithInt:newMax];
      }
    }
  }
}

- (void)setParentWithJavaLangThreadGroup:(JavaLangThreadGroup *)parent {
  if (parent != nil) {
    [parent addWithJavaLangThreadGroup:self];
  }
  JavaLangThreadGroup_set_parent_(self, parent);
}

- (NSString *)description {
  return [NSString stringWithFormat:@"%@[name=%@,maxpri=%d]", [[self getClass] getName], [self getName], [self getMaxPriority]];
}

- (void)uncaughtExceptionWithJavaLangThread:(JavaLangThread *)t
                      withJavaLangThrowable:(JavaLangThrowable *)e {
  if (parent_ != nil) {
    [parent_ uncaughtExceptionWithJavaLangThread:t withJavaLangThrowable:e];
  }
  else if (!([e isKindOfClass:[JavaLangThreadDeath class]])) {
    [((JavaLangThrowable *) nil_chk(e)) printStackTrace];
  }
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaLangThreadGroup_set_childrenThreadsLock_(self, nil);
  JavaLangThreadGroup_set_childrenGroupsLock_(self, nil);
  JavaLangThreadGroup_set_childrenGroups_(self, nil);
  JavaLangThreadGroup_set_childrenThreads_(self, nil);
  JavaLangThreadGroup_set_parent_(self, nil);
  JavaLangThreadGroup_set_name_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaLangThreadGroup *)other {
  [super copyAllFieldsTo:other];
  JavaLangThreadGroup_set_childrenGroups_(other, childrenGroups_);
  JavaLangThreadGroup_set_childrenGroupsLock_(other, childrenGroupsLock_);
  JavaLangThreadGroup_set_childrenThreads_(other, childrenThreads_);
  JavaLangThreadGroup_set_childrenThreadsLock_(other, childrenThreadsLock_);
  other->isDestroyed__ = isDestroyed__;
  other->maxPriority_ = maxPriority_;
  JavaLangThreadGroup_set_name_(other, name_);
  other->numGroups_ = numGroups_;
  other->numThreads_ = numThreads_;
  JavaLangThreadGroup_set_parent_(other, parent_);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:name_ name:@"name"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:parent_ name:@"parent"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:childrenThreads_ name:@"childrenThreads"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:childrenGroups_ name:@"childrenGroups"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:childrenGroupsLock_ name:@"childrenGroupsLock"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:childrenThreadsLock_ name:@"childrenThreadsLock"]];
  return result;
}

@end
@implementation JavaLangThreadGroup_ChildrenGroupsLock

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithJavaLangThreadGroup:(JavaLangThreadGroup *)outer$ {
  return JreMemDebugAdd([super init]);
}

@end
@implementation JavaLangThreadGroup_ChildrenThreadsLock

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

- (id)initWithJavaLangThreadGroup:(JavaLangThreadGroup *)outer$ {
  return JreMemDebugAdd([super init]);
}

@end
