//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//
//  Created by Larry Tin <dev@goodow.com>
//

#include "IOSClass.h"
#include "IOSDoubleArray.h"
#include "java/lang/ClassCastException.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/StringBuilder.h"
#include "java/nio/Buffer.h"
#include "java/nio/BufferFactory.h"
#include "java/nio/BufferOverflowException.h"
#include "java/nio/BufferUnderflowException.h"
#include "java/nio/ByteOrder.h"
#include "java/nio/DoubleBuffer.h"

@implementation JavaNioDoubleBuffer

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  return result;
}

+ (JavaNioDoubleBuffer *)allocateWithInt:(int)capacity {
  if (capacity < 0) {
    @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
  }
  return [JavaNioBufferFactory newDoubleBufferWithInt:capacity];
}

+ (JavaNioDoubleBuffer *)wrapWithDoubleArray:(IOSDoubleArray *)array {
  return [JavaNioDoubleBuffer wrapWithDoubleArray:array withInt:0 withInt:(int) [((IOSDoubleArray *) nil_chk(array)) count]];
}

+ (JavaNioDoubleBuffer *)wrapWithDoubleArray:(IOSDoubleArray *)array
                                     withInt:(int)start
                                     withInt:(int)len {
  int length = (int) [((IOSDoubleArray *) nil_chk(array)) count];
  if (start < 0 || len < 0 || (long long int) start + (long long int) len > length) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
  }
  JavaNioDoubleBuffer *buf = [JavaNioBufferFactory newDoubleBufferWithDoubleArray:array];
  ((JavaNioDoubleBuffer *) nil_chk(buf))->position__ = start;
  buf->limit__ = start + len;
  return buf;
}

- (id)initWithInt:(int)capacity {
  return JreMemDebugAdd([super initWithInt:capacity]);
}

- (IOSDoubleArray *)array {
  return [self protectedArray];
}

- (int)arrayOffset {
  return [self protectedArrayOffset];
}

- (JavaNioDoubleBuffer *)asReadOnlyBuffer {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (JavaNioDoubleBuffer *)compact {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (int)compareToWithId:(JavaNioDoubleBuffer *)otherBuffer {
  if (otherBuffer != nil && ![otherBuffer isKindOfClass:[JavaNioDoubleBuffer class]]) {
    @throw [[[JavaLangClassCastException alloc] init] autorelease];
  }
  int compareRemaining = ([self remaining] < [((JavaNioDoubleBuffer *) nil_chk(otherBuffer)) remaining]) ? [self remaining] : [otherBuffer remaining];
  int thisPos = position__;
  int otherPos = otherBuffer->position__;
  double thisDouble, otherDouble;
  while (compareRemaining > 0) {
    thisDouble = [self getWithInt:thisPos];
    otherDouble = [otherBuffer getWithInt:otherPos];
    if ((thisDouble != otherDouble) && ((thisDouble == thisDouble) || (otherDouble == otherDouble))) {
      return thisDouble < otherDouble ? -1 : 1;
    }
    thisPos++;
    otherPos++;
    compareRemaining--;
  }
  return [self remaining] - [otherBuffer remaining];
}

- (JavaNioDoubleBuffer *)duplicate {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (BOOL)isEqual:(id)other {
  if (!([other isKindOfClass:[JavaNioDoubleBuffer class]])) {
    return NO;
  }
  JavaNioDoubleBuffer *otherBuffer = (JavaNioDoubleBuffer *) check_class_cast(other, [JavaNioDoubleBuffer class]);
  if ([self remaining] != [((JavaNioDoubleBuffer *) nil_chk(otherBuffer)) remaining]) {
    return NO;
  }
  int myPosition = position__;
  int otherPosition = otherBuffer->position__;
  BOOL equalSoFar = YES;
  while (equalSoFar && (myPosition < limit__)) {
    double a = [self getWithInt:myPosition++];
    double b = [otherBuffer getWithInt:otherPosition++];
    equalSoFar = a == b || (a != a && b != b);
  }
  return equalSoFar;
}

- (double)get {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (JavaNioDoubleBuffer *)getWithDoubleArray:(IOSDoubleArray *)dest {
  return [self getWithDoubleArray:dest withInt:0 withInt:(int) [((IOSDoubleArray *) nil_chk(dest)) count]];
}

- (JavaNioDoubleBuffer *)getWithDoubleArray:(IOSDoubleArray *)dest
                                    withInt:(int)off
                                    withInt:(int)len {
  int length = (int) [((IOSDoubleArray *) nil_chk(dest)) count];
  if (off < 0 || len < 0 || (long long int) off + (long long int) len > length) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
  }
  if (len > [self remaining]) {
    @throw [[[JavaNioBufferUnderflowException alloc] init] autorelease];
  }
  for (int i = off; i < off + len; i++) {
    (*IOSDoubleArray_GetRef(dest, i)) = [self get];
  }
  return self;
}

- (double)getWithInt:(int)index {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (BOOL)hasArray {
  return [self protectedHasArray];
}

- (NSUInteger)hash {
  int myPosition = position__;
  int hash_ = 0;
  long long int l;
  while (myPosition < limit__) {
    l = [JavaLangDouble doubleToLongBitsWithDouble:[self getWithInt:myPosition++]];
    hash_ = hash_ + ((int) l) ^ ((int) (l >> 32));
  }
  return hash_;
}

- (BOOL)isDirect {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (JavaNioByteOrder *)order {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (IOSDoubleArray *)protectedArray {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (int)protectedArrayOffset {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (BOOL)protectedHasArray {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (JavaNioDoubleBuffer *)putWithDouble:(double)d {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (JavaNioDoubleBuffer *)putWithDoubleArray:(IOSDoubleArray *)src {
  return [self putWithDoubleArray:src withInt:0 withInt:(int) [((IOSDoubleArray *) nil_chk(src)) count]];
}

- (JavaNioDoubleBuffer *)putWithDoubleArray:(IOSDoubleArray *)src
                                    withInt:(int)off
                                    withInt:(int)len {
  int length = (int) [((IOSDoubleArray *) nil_chk(src)) count];
  if (off < 0 || len < 0 || (long long int) off + (long long int) len > length) {
    @throw [[[JavaLangIndexOutOfBoundsException alloc] init] autorelease];
  }
  if (len > [self remaining]) {
    @throw [[[JavaNioBufferOverflowException alloc] init] autorelease];
  }
  for (int i = off; i < off + len; i++) {
    [self putWithDouble:IOSDoubleArray_Get(src, i)];
  }
  return self;
}

- (JavaNioDoubleBuffer *)putWithJavaNioDoubleBuffer:(JavaNioDoubleBuffer *)src {
  if (src == self) {
    @throw [[[JavaLangIllegalArgumentException alloc] init] autorelease];
  }
  if ([((JavaNioDoubleBuffer *) nil_chk(src)) remaining] > [self remaining]) {
    @throw [[[JavaNioBufferOverflowException alloc] init] autorelease];
  }
  IOSDoubleArray *doubles = [IOSDoubleArray arrayWithLength:[src remaining]];
  [src getWithDoubleArray:doubles];
  [self putWithDoubleArray:doubles];
  return self;
}

- (JavaNioDoubleBuffer *)putWithInt:(int)index
                         withDouble:(double)d {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (JavaNioDoubleBuffer *)slice {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (NSString *)description {
  JavaLangStringBuilder *buf = [[[JavaLangStringBuilder alloc] init] autorelease];
  [buf appendWithNSString:[[self getClass] getName]];
  [buf appendWithNSString:@", status: capacity="];
  [buf appendWithInt:[self capacity]];
  [buf appendWithNSString:@" position="];
  [buf appendWithInt:[self position]];
  [buf appendWithNSString:@" limit="];
  [buf appendWithInt:[self limit]];
  return [buf description];
}

@end
