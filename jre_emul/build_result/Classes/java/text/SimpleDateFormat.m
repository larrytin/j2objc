//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//
//  Created by Larry Tin <dev@goodow.com>
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "java/lang/Character.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Long.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/StringBuffer.h"
#include "java/lang/StringBuilder.h"
#include "java/text/AttributedCharacterIterator.h"
#include "java/text/AttributedString.h"
#include "java/text/DateFormat.h"
#include "java/text/DateFormatSymbols.h"
#include "java/text/DecimalFormat.h"
#include "java/text/DecimalFormatSymbols.h"
#include "java/text/FieldPosition.h"
#include "java/text/Format.h"
#include "java/text/NumberFormat.h"
#include "java/text/ParsePosition.h"
#include "java/text/SimpleDateFormat.h"
#include "java/util/ArrayList.h"
#include "java/util/Calendar.h"
#include "java/util/Date.h"
#include "java/util/GregorianCalendar.h"
#include "java/util/List.h"
#include "java/util/Locale.h"
#include "java/util/SimpleTimeZone.h"
#include "java/util/TimeZone.h"
#include "libcore/icu/LocaleData.h"
#include "libcore/icu/TimeZoneNames.h"

@implementation JavaTextSimpleDateFormat

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaTextSimpleDateFormat_PATTERN_CHARS_ name:@"JavaTextSimpleDateFormat_PATTERN_CHARS_"]];
  return result;
}

static NSString * JavaTextSimpleDateFormat_PATTERN_CHARS_ = @"GyMdkHmsSEDFwWahKzZLc";

+ (NSString *)PATTERN_CHARS {
  return JavaTextSimpleDateFormat_PATTERN_CHARS_;
}

- (id)init {
  if (self = [self initJavaTextSimpleDateFormatWithJavaUtilLocale:[JavaUtilLocale getDefault]]) {
    JavaTextSimpleDateFormat_set_pattern_(self, [JavaTextSimpleDateFormat defaultPattern]);
    JavaTextSimpleDateFormat_set_formatData_(self, [[[JavaTextDateFormatSymbols alloc] initWithJavaUtilLocale:[JavaUtilLocale getDefault]] autorelease]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithNSString:(NSString *)pattern {
  return JreMemDebugAdd([self initJavaTextSimpleDateFormatWithNSString:pattern withJavaUtilLocale:[JavaUtilLocale getDefault]]);
}

- (void)validatePatternWithNSString:(NSString *)template_ {
  BOOL quote = NO;
  int next, last = -1, count = 0;
  int patternLength = [((NSString *) nil_chk(template_)) length];
  for (int i = 0; i < patternLength; i++) {
    next = ([template_ charAtWithInt:i]);
    if (next == '\'') {
      if (count > 0) {
        [self validatePatternCharacterWithChar:(unichar) last];
        count = 0;
      }
      if (last == next) {
        last = -1;
      }
      else {
        last = next;
      }
      quote = !quote;
      continue;
    }
    if (!quote && (last == next || (next >= 'a' && next <= 'z') || (next >= 'A' && next <= 'Z'))) {
      if (last == next) {
        count++;
      }
      else {
        if (count > 0) {
          [self validatePatternCharacterWithChar:(unichar) last];
        }
        last = next;
        count = 1;
      }
    }
    else {
      if (count > 0) {
        [self validatePatternCharacterWithChar:(unichar) last];
        count = 0;
      }
      last = -1;
    }
  }
  if (count > 0) {
    [self validatePatternCharacterWithChar:(unichar) last];
  }
  if (quote) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Unterminated quote"] autorelease];
  }
}

- (void)validatePatternCharacterWithChar:(unichar)format {
  int index = [((NSString *) nil_chk(JavaTextSimpleDateFormat_PATTERN_CHARS_)) indexOf:format];
  if (index == -1) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"Unknown pattern character '%C'", format]] autorelease];
  }
}

- (id)initWithNSString:(NSString *)template_
withJavaTextDateFormatSymbols:(JavaTextDateFormatSymbols *)value {
  if (self = [self initJavaTextSimpleDateFormatWithJavaUtilLocale:[JavaUtilLocale getDefault]]) {
    [self validatePatternWithNSString:template_];
    JavaTextSimpleDateFormat_set_pattern_(self, template_);
    JavaTextSimpleDateFormat_set_formatData_(self, (JavaTextDateFormatSymbols *) check_class_cast([((JavaTextDateFormatSymbols *) nil_chk(value)) clone], [JavaTextDateFormatSymbols class]));
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initJavaTextSimpleDateFormatWithNSString:(NSString *)template_
                            withJavaUtilLocale:(JavaUtilLocale *)locale {
  if (self = [self initJavaTextSimpleDateFormatWithJavaUtilLocale:locale]) {
    [self validatePatternWithNSString:template_];
    JavaTextSimpleDateFormat_set_pattern_(self, template_);
    JavaTextSimpleDateFormat_set_formatData_(self, [[[JavaTextDateFormatSymbols alloc] initWithJavaUtilLocale:locale] autorelease]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithNSString:(NSString *)template_
    withJavaUtilLocale:(JavaUtilLocale *)locale {
  return [self initJavaTextSimpleDateFormatWithNSString:template_ withJavaUtilLocale:locale];
}

- (id)initJavaTextSimpleDateFormatWithJavaUtilLocale:(JavaUtilLocale *)locale {
  if (self = [super init]) {
    JavaTextDateFormat_set_numberFormat_(self, [JavaTextNumberFormat getInstanceWithJavaUtilLocale:locale]);
    [((JavaTextNumberFormat *) nil_chk(numberFormat_)) setParseIntegerOnlyWithBoolean:YES];
    [numberFormat_ setGroupingUsedWithBoolean:NO];
    JavaTextDateFormat_set_calendar_(self, [[[JavaUtilGregorianCalendar alloc] initWithJavaUtilLocale:locale] autorelease]);
    [calendar_ addWithInt:JavaUtilCalendar_YEAR withInt:-80];
    creationYear_ = [calendar_ getWithInt:JavaUtilCalendar_YEAR];
    JavaTextSimpleDateFormat_set_defaultCenturyStart_(self, [calendar_ getTime]);
    JreMemDebugAdd(self);
  }
  return self;
}

- (id)initWithJavaUtilLocale:(JavaUtilLocale *)locale {
  return [self initJavaTextSimpleDateFormatWithJavaUtilLocale:locale];
}

- (void)applyLocalizedPatternWithNSString:(NSString *)template_ {
  JavaTextSimpleDateFormat_set_pattern_(self, [JavaTextSimpleDateFormat convertPatternWithNSString:template_ withNSString:[((JavaTextDateFormatSymbols *) nil_chk(formatData_)) getLocalPatternChars] withNSString:JavaTextSimpleDateFormat_PATTERN_CHARS_ withBoolean:YES]);
}

- (void)applyPatternWithNSString:(NSString *)template_ {
  [self validatePatternWithNSString:template_];
  JavaTextSimpleDateFormat_set_pattern_(self, template_);
}

- (id)clone {
  JavaTextSimpleDateFormat *clone = (JavaTextSimpleDateFormat *) check_class_cast([super clone], [JavaTextSimpleDateFormat class]);
  JavaTextSimpleDateFormat_set_formatData_(nil_chk(clone), (JavaTextDateFormatSymbols *) check_class_cast([((JavaTextDateFormatSymbols *) nil_chk(formatData_)) clone], [JavaTextDateFormatSymbols class]));
  JavaTextSimpleDateFormat_set_defaultCenturyStart_(clone, [[[JavaUtilDate alloc] initWithLong:[((JavaUtilDate *) nil_chk(defaultCenturyStart_)) getTime]] autorelease]);
  return clone;
}

+ (NSString *)defaultPattern {
  LibcoreIcuLocaleData *localeData = [LibcoreIcuLocaleData getWithJavaUtilLocale:[JavaUtilLocale getDefault]];
  return [NSString stringWithFormat:@"%@ %@", [((LibcoreIcuLocaleData *) nil_chk(localeData)) getDateFormatWithInt:JavaTextDateFormat_SHORT], [localeData getTimeFormatWithInt:JavaTextDateFormat_SHORT]];
}

- (BOOL)isEqual:(id)object {
  if (self == object) {
    return YES;
  }
  if (!([object isKindOfClass:[JavaTextSimpleDateFormat class]])) {
    return NO;
  }
  JavaTextSimpleDateFormat *simple = (JavaTextSimpleDateFormat *) check_class_cast(object, [JavaTextSimpleDateFormat class]);
  return [super isEqual:object] && [((NSString *) nil_chk(pattern_)) isEqual:((JavaTextSimpleDateFormat *) nil_chk(simple))->pattern_] && [((JavaTextDateFormatSymbols *) nil_chk(formatData_)) isEqual:simple->formatData_];
}

- (id<JavaTextAttributedCharacterIterator>)formatToCharacterIteratorWithId:(id)object {
  if (object == nil) {
    @throw [[[JavaLangNullPointerException alloc] initWithNSString:@"object == null"] autorelease];
  }
  if ([object isKindOfClass:[JavaUtilDate class]]) {
    return [self formatToCharacterIteratorImplWithJavaUtilDate:(JavaUtilDate *) check_class_cast(object, [JavaUtilDate class])];
  }
  if ([object isKindOfClass:[NSNumber class]]) {
    return [self formatToCharacterIteratorImplWithJavaUtilDate:[[[JavaUtilDate alloc] initWithLong:[((NSNumber *) nil_chk(object)) longLongValue]] autorelease]];
  }
  @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"Bad class: %@", [nil_chk(object) getClass]]] autorelease];
}

- (id<JavaTextAttributedCharacterIterator>)formatToCharacterIteratorImplWithJavaUtilDate:(JavaUtilDate *)date {
  JavaLangStringBuffer *buffer = [[[JavaLangStringBuffer alloc] init] autorelease];
  JavaUtilArrayList *fields = [[[JavaUtilArrayList alloc] init] autorelease];
  [self formatImplWithJavaUtilDate:date withJavaLangStringBuffer:buffer withJavaTextFieldPosition:nil withJavaUtilList:fields];
  JavaTextAttributedString *as = [[[JavaTextAttributedString alloc] initWithNSString:[buffer description]] autorelease];
  for (JavaTextFieldPosition * __strong pos in fields) {
    JavaTextFormat_Field *attribute = [((JavaTextFieldPosition *) nil_chk(pos)) getFieldAttribute];
    [as addAttributeWithJavaTextAttributedCharacterIterator_Attribute:attribute withId:attribute withInt:[pos getBeginIndex] withInt:[pos getEndIndex]];
  }
  return [as getIterator];
}

- (JavaLangStringBuffer *)formatImplWithJavaUtilDate:(JavaUtilDate *)date
                            withJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                           withJavaTextFieldPosition:(JavaTextFieldPosition *)field
                                    withJavaUtilList:(id<JavaUtilList>)fields {
  BOOL quote = NO;
  int next, last = -1, count = 0;
  [((JavaUtilCalendar *) nil_chk(calendar_)) setTimeWithJavaUtilDate:date];
  if (field != nil) {
    [field clear];
  }
  int patternLength = [((NSString *) nil_chk(pattern_)) length];
  for (int i = 0; i < patternLength; i++) {
    next = ([pattern_ charAtWithInt:i]);
    if (next == '\'') {
      if (count > 0) {
        [self appendWithJavaLangStringBuffer:buffer withJavaTextFieldPosition:field withJavaUtilList:fields withChar:(unichar) last withInt:count];
        count = 0;
      }
      if (last == next) {
        [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithChar:'\''];
        last = -1;
      }
      else {
        last = next;
      }
      quote = !quote;
      continue;
    }
    if (!quote && (last == next || (next >= 'a' && next <= 'z') || (next >= 'A' && next <= 'Z'))) {
      if (last == next) {
        count++;
      }
      else {
        if (count > 0) {
          [self appendWithJavaLangStringBuffer:buffer withJavaTextFieldPosition:field withJavaUtilList:fields withChar:(unichar) last withInt:count];
        }
        last = next;
        count = 1;
      }
    }
    else {
      if (count > 0) {
        [self appendWithJavaLangStringBuffer:buffer withJavaTextFieldPosition:field withJavaUtilList:fields withChar:(unichar) last withInt:count];
        count = 0;
      }
      last = -1;
      [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithChar:(unichar) next];
    }
  }
  if (count > 0) {
    [self appendWithJavaLangStringBuffer:buffer withJavaTextFieldPosition:field withJavaUtilList:fields withChar:(unichar) last withInt:count];
  }
  return buffer;
}

- (void)appendWithJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
             withJavaTextFieldPosition:(JavaTextFieldPosition *)position
                      withJavaUtilList:(id<JavaUtilList>)fields
                              withChar:(unichar)format
                               withInt:(int)count {
  int field = -1;
  int index = [((NSString *) nil_chk(JavaTextSimpleDateFormat_PATTERN_CHARS_)) indexOf:format];
  if (index == -1) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"Unknown pattern character '%C'", format]] autorelease];
  }
  int beginPosition = [((JavaLangStringBuffer *) nil_chk(buffer)) sequenceLength];
  JavaTextDateFormat_Field *dateFormatField = nil;
  {
    int year;
    int hour;
    int value;
    switch (index) {
      case JavaTextDateFormat_ERA_FIELD:
      dateFormatField = [JavaTextDateFormat_Field ERA];
      [buffer appendWithNSString:IOSObjectArray_Get(nil_chk(((JavaTextDateFormatSymbols *) nil_chk(formatData_))->eras_), [((JavaUtilCalendar *) nil_chk(calendar_)) getWithInt:JavaUtilCalendar_ERA])];
      break;
      case JavaTextDateFormat_YEAR_FIELD:
      dateFormatField = [JavaTextDateFormat_Field YEAR];
      year = [((JavaUtilCalendar *) nil_chk(calendar_)) getWithInt:JavaUtilCalendar_YEAR];
      if (count == 2) {
        [self appendNumberWithJavaLangStringBuffer:buffer withInt:2 withInt:year % 100];
      }
      else {
        [self appendNumberWithJavaLangStringBuffer:buffer withInt:count withInt:year];
      }
      break;
      case JavaTextSimpleDateFormat_STAND_ALONE_MONTH_FIELD:
      dateFormatField = [JavaTextDateFormat_Field MONTH];
      [self appendMonthWithJavaLangStringBuffer:buffer withInt:count withBoolean:YES];
      break;
      case JavaTextDateFormat_MONTH_FIELD:
      dateFormatField = [JavaTextDateFormat_Field MONTH];
      [self appendMonthWithJavaLangStringBuffer:buffer withInt:count withBoolean:NO];
      break;
      case JavaTextDateFormat_DATE_FIELD:
      dateFormatField = [JavaTextDateFormat_Field DAY_OF_MONTH];
      field = JavaUtilCalendar_DATE;
      break;
      case JavaTextDateFormat_HOUR_OF_DAY1_FIELD:
      dateFormatField = [JavaTextDateFormat_Field HOUR_OF_DAY1];
      hour = [((JavaUtilCalendar *) nil_chk(calendar_)) getWithInt:JavaUtilCalendar_HOUR_OF_DAY];
      [self appendNumberWithJavaLangStringBuffer:buffer withInt:count withInt:hour == 0 ? 24 : hour];
      break;
      case JavaTextDateFormat_HOUR_OF_DAY0_FIELD:
      dateFormatField = [JavaTextDateFormat_Field HOUR_OF_DAY0];
      field = JavaUtilCalendar_HOUR_OF_DAY;
      break;
      case JavaTextDateFormat_MINUTE_FIELD:
      dateFormatField = [JavaTextDateFormat_Field MINUTE];
      field = JavaUtilCalendar_MINUTE;
      break;
      case JavaTextDateFormat_SECOND_FIELD:
      dateFormatField = [JavaTextDateFormat_Field SECOND];
      field = JavaUtilCalendar_SECOND;
      break;
      case JavaTextDateFormat_MILLISECOND_FIELD:
      dateFormatField = [JavaTextDateFormat_Field MILLISECOND];
      value = [((JavaUtilCalendar *) nil_chk(calendar_)) getWithInt:JavaUtilCalendar_MILLISECOND];
      [self appendNumberWithJavaLangStringBuffer:buffer withInt:count withInt:value];
      break;
      case JavaTextSimpleDateFormat_STAND_ALONE_DAY_OF_WEEK_FIELD:
      dateFormatField = [JavaTextDateFormat_Field DAY_OF_WEEK];
      [self appendDayOfWeekWithJavaLangStringBuffer:buffer withInt:count withBoolean:YES];
      break;
      case JavaTextDateFormat_DAY_OF_WEEK_FIELD:
      dateFormatField = [JavaTextDateFormat_Field DAY_OF_WEEK];
      [self appendDayOfWeekWithJavaLangStringBuffer:buffer withInt:count withBoolean:NO];
      break;
      case JavaTextDateFormat_DAY_OF_YEAR_FIELD:
      dateFormatField = [JavaTextDateFormat_Field DAY_OF_YEAR];
      field = JavaUtilCalendar_DAY_OF_YEAR;
      break;
      case JavaTextDateFormat_DAY_OF_WEEK_IN_MONTH_FIELD:
      dateFormatField = [JavaTextDateFormat_Field DAY_OF_WEEK_IN_MONTH];
      field = JavaUtilCalendar_DAY_OF_WEEK_IN_MONTH;
      break;
      case JavaTextDateFormat_WEEK_OF_YEAR_FIELD:
      dateFormatField = [JavaTextDateFormat_Field WEEK_OF_YEAR];
      field = JavaUtilCalendar_WEEK_OF_YEAR;
      break;
      case JavaTextDateFormat_WEEK_OF_MONTH_FIELD:
      dateFormatField = [JavaTextDateFormat_Field WEEK_OF_MONTH];
      field = JavaUtilCalendar_WEEK_OF_MONTH;
      break;
      case JavaTextDateFormat_AM_PM_FIELD:
      dateFormatField = [JavaTextDateFormat_Field AM_PM];
      [buffer appendWithNSString:IOSObjectArray_Get(nil_chk(((JavaTextDateFormatSymbols *) nil_chk(formatData_))->ampms_), [((JavaUtilCalendar *) nil_chk(calendar_)) getWithInt:JavaUtilCalendar_AM_PM])];
      break;
      case JavaTextDateFormat_HOUR1_FIELD:
      dateFormatField = [JavaTextDateFormat_Field HOUR1];
      hour = [((JavaUtilCalendar *) nil_chk(calendar_)) getWithInt:JavaUtilCalendar_HOUR];
      [self appendNumberWithJavaLangStringBuffer:buffer withInt:count withInt:hour == 0 ? 12 : hour];
      break;
      case JavaTextDateFormat_HOUR0_FIELD:
      dateFormatField = [JavaTextDateFormat_Field HOUR0];
      field = JavaUtilCalendar_HOUR;
      break;
      case JavaTextDateFormat_TIMEZONE_FIELD:
      dateFormatField = [JavaTextDateFormat_Field TIME_ZONE];
      [self appendTimeZoneWithJavaLangStringBuffer:buffer withInt:count withBoolean:YES];
      break;
      case JavaTextSimpleDateFormat_RFC_822_TIMEZONE_FIELD:
      dateFormatField = [JavaTextDateFormat_Field TIME_ZONE];
      [self appendNumericTimeZoneWithJavaLangStringBuffer:buffer withInt:count withBoolean:NO];
      break;
    }
  }
  if (field != -1) {
    [self appendNumberWithJavaLangStringBuffer:buffer withInt:count withInt:[((JavaUtilCalendar *) nil_chk(calendar_)) getWithInt:field]];
  }
  if (fields != nil) {
    position = [[[JavaTextFieldPosition alloc] initWithJavaTextFormat_Field:dateFormatField] autorelease];
    [position setBeginIndexWithInt:beginPosition];
    [position setEndIndexWithInt:[buffer sequenceLength]];
    [fields addWithId:position];
  }
  else {
    if (([((JavaTextFieldPosition *) nil_chk(position)) getFieldAttribute] == dateFormatField || ([position getFieldAttribute] == nil && [position getField] == index)) && [position getEndIndex] == 0) {
      [position setBeginIndexWithInt:beginPosition];
      [position setEndIndexWithInt:[buffer sequenceLength]];
    }
  }
}

- (void)appendDayOfWeekWithJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                                        withInt:(int)count
                                    withBoolean:(BOOL)standAlone {
  IOSObjectArray *days;
  LibcoreIcuLocaleData *ld = ((JavaTextDateFormatSymbols *) nil_chk(formatData_))->localeData_;
  if (count == 4) {
    days = standAlone ? ((LibcoreIcuLocaleData *) nil_chk(ld))->longStandAloneWeekdayNames_ : formatData_->weekdays_;
  }
  else if (count == 5) {
    days = standAlone ? ((LibcoreIcuLocaleData *) nil_chk(ld))->tinyStandAloneWeekdayNames_ : ((LibcoreIcuLocaleData *) nil_chk(formatData_->localeData_))->tinyWeekdayNames_;
  }
  else {
    days = standAlone ? ((LibcoreIcuLocaleData *) nil_chk(ld))->shortStandAloneWeekdayNames_ : formatData_->shortWeekdays_;
  }
  [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithNSString:IOSObjectArray_Get(nil_chk(days), [((JavaUtilCalendar *) nil_chk(calendar_)) getWithInt:JavaUtilCalendar_DAY_OF_WEEK])];
}

- (void)appendMonthWithJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                                    withInt:(int)count
                                withBoolean:(BOOL)standAlone {
  int month = [((JavaUtilCalendar *) nil_chk(calendar_)) getWithInt:JavaUtilCalendar_MONTH];
  if (count <= 2) {
    [self appendNumberWithJavaLangStringBuffer:buffer withInt:count withInt:month + 1];
    return;
  }
  IOSObjectArray *months;
  LibcoreIcuLocaleData *ld = ((JavaTextDateFormatSymbols *) nil_chk(formatData_))->localeData_;
  if (count == 4) {
    months = standAlone ? ((LibcoreIcuLocaleData *) nil_chk(ld))->longStandAloneMonthNames_ : formatData_->months_;
  }
  else if (count == 5) {
    months = standAlone ? ((LibcoreIcuLocaleData *) nil_chk(ld))->tinyStandAloneMonthNames_ : ((LibcoreIcuLocaleData *) nil_chk(ld))->tinyMonthNames_;
  }
  else {
    months = standAlone ? ((LibcoreIcuLocaleData *) nil_chk(ld))->shortStandAloneMonthNames_ : formatData_->shortMonths_;
  }
  [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithNSString:IOSObjectArray_Get(nil_chk(months), month)];
}

- (void)appendTimeZoneWithJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                                       withInt:(int)count
                                   withBoolean:(BOOL)generalTimeZone {
  if (generalTimeZone) {
    JavaUtilTimeZone *tz = [((JavaUtilCalendar *) nil_chk(calendar_)) getTimeZone];
    BOOL daylight = ([calendar_ getWithInt:JavaUtilCalendar_DST_OFFSET] != 0);
    int style = count < 4 ? JavaUtilTimeZone_SHORT : JavaUtilTimeZone_LONG;
    if (!((JavaTextDateFormatSymbols *) nil_chk(formatData_))->customZoneStrings_) {
      [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithNSString:[((JavaUtilTimeZone *) nil_chk(tz)) getDisplayNameWithBoolean:daylight withInt:style withJavaUtilLocale:formatData_->locale_]];
      return;
    }
    NSString *custom = [LibcoreIcuTimeZoneNames getDisplayNameWithNSStringArray2:formatData_->zoneStrings_ withNSString:[((JavaUtilTimeZone *) nil_chk(tz)) getID] withBoolean:daylight withInt:style];
    if (custom != nil) {
      [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithNSString:custom];
      return;
    }
  }
  [self appendNumericTimeZoneWithJavaLangStringBuffer:buffer withInt:count withBoolean:generalTimeZone];
}

- (void)appendNumericTimeZoneWithJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                                              withInt:(int)count
                                          withBoolean:(BOOL)generalTimeZone {
  int offset = [((JavaUtilCalendar *) nil_chk(calendar_)) getWithInt:JavaUtilCalendar_ZONE_OFFSET] + [calendar_ getWithInt:JavaUtilCalendar_DST_OFFSET];
  unichar sign = '+';
  if (offset < 0) {
    sign = '-';
    offset = -offset;
  }
  if (generalTimeZone || count == 4) {
    [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithNSString:@"GMT"];
  }
  [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithChar:sign];
  [self appendNumberWithJavaLangStringBuffer:buffer withInt:2 withInt:offset / 3600000];
  if (generalTimeZone || count >= 4) {
    [buffer appendWithChar:':'];
  }
  [self appendNumberWithJavaLangStringBuffer:buffer withInt:2 withInt:(offset % 3600000) / 60000];
}

- (void)appendNumberWithJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                                     withInt:(int)count
                                     withInt:(int)value {
  int minimumIntegerDigits = [((JavaTextNumberFormat *) nil_chk(numberFormat_)) getMinimumIntegerDigits];
  [numberFormat_ setMinimumIntegerDigitsWithInt:count];
  [numberFormat_ formatWithId:[JavaLangInteger valueOfWithInt:value] withJavaLangStringBuffer:buffer withJavaTextFieldPosition:[[[JavaTextFieldPosition alloc] initWithInt:0] autorelease]];
  [numberFormat_ setMinimumIntegerDigitsWithInt:minimumIntegerDigits];
}

- (JavaUtilDate *)errorWithJavaTextParsePosition:(JavaTextParsePosition *)position
                                         withInt:(int)offset
                            withJavaUtilTimeZone:(JavaUtilTimeZone *)zone {
  [((JavaTextParsePosition *) nil_chk(position)) setErrorIndexWithInt:offset];
  [((JavaUtilCalendar *) nil_chk(calendar_)) setTimeZoneWithJavaUtilTimeZone:zone];
  return nil;
}

- (JavaLangStringBuffer *)formatWithJavaUtilDate:(JavaUtilDate *)date
                        withJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                       withJavaTextFieldPosition:(JavaTextFieldPosition *)fieldPos {
  return [self formatImplWithJavaUtilDate:date withJavaLangStringBuffer:buffer withJavaTextFieldPosition:fieldPos withJavaUtilList:nil];
}

- (JavaUtilDate *)get2DigitYearStart {
  return (JavaUtilDate *) check_class_cast([((JavaUtilDate *) nil_chk(defaultCenturyStart_)) clone], [JavaUtilDate class]);
}

- (JavaTextDateFormatSymbols *)getDateFormatSymbols {
  return (JavaTextDateFormatSymbols *) check_class_cast([((JavaTextDateFormatSymbols *) nil_chk(formatData_)) clone], [JavaTextDateFormatSymbols class]);
}

- (NSUInteger)hash {
  return [super hash] + [((NSString *) nil_chk(pattern_)) hash] + [((JavaTextDateFormatSymbols *) nil_chk(formatData_)) hash] + creationYear_;
}

- (int)parseWithNSString:(NSString *)string
                 withInt:(int)offset
                withChar:(unichar)format
                 withInt:(int)count {
  int index = [((NSString *) nil_chk(JavaTextSimpleDateFormat_PATTERN_CHARS_)) indexOf:format];
  if (index == -1) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"Unknown pattern character '%C'", format]] autorelease];
  }
  int field = -1;
  int absolute = 0;
  if (count < 0) {
    count = -count;
    absolute = count;
  }
  {
    JavaTextParsePosition *position;
    NSNumber *result;
    int hour;
    switch (index) {
      case JavaTextDateFormat_ERA_FIELD:
      return [self parseTextWithNSString:string withInt:offset withNSStringArray:((JavaTextDateFormatSymbols *) nil_chk(formatData_))->eras_ withInt:JavaUtilCalendar_ERA];
      case JavaTextDateFormat_YEAR_FIELD:
      if (count >= 3) {
        field = JavaUtilCalendar_YEAR;
      }
      else {
        JavaTextParsePosition *position = [[[JavaTextParsePosition alloc] initWithInt:offset] autorelease];
        NSNumber *result = [self parseNumberWithInt:absolute withNSString:string withJavaTextParsePosition:position];
        if (result == nil) {
          return -[position getErrorIndex] - 1;
        }
        int year = [((NSNumber *) nil_chk(result)) intValue];
        if (([position getIndex] - offset) == 2 && year >= 0) {
          year += creationYear_ / 100 * 100;
          if (year < creationYear_) {
            year += 100;
          }
        }
        [((JavaUtilCalendar *) nil_chk(calendar_)) setWithInt:JavaUtilCalendar_YEAR withInt:year];
        return [position getIndex];
      }
      break;
      case JavaTextSimpleDateFormat_STAND_ALONE_MONTH_FIELD:
      return [self parseMonthWithNSString:string withInt:offset withInt:count withInt:absolute withBoolean:YES];
      case JavaTextDateFormat_MONTH_FIELD:
      return [self parseMonthWithNSString:string withInt:offset withInt:count withInt:absolute withBoolean:NO];
      case JavaTextDateFormat_DATE_FIELD:
      field = JavaUtilCalendar_DATE;
      break;
      case JavaTextDateFormat_HOUR_OF_DAY1_FIELD:
      position = [[[JavaTextParsePosition alloc] initWithInt:offset] autorelease];
      result = [self parseNumberWithInt:absolute withNSString:string withJavaTextParsePosition:position];
      if (result == nil) {
        return -[position getErrorIndex] - 1;
      }
      hour = [((NSNumber *) nil_chk(result)) intValue];
      if (hour == 24) {
        hour = 0;
      }
      [((JavaUtilCalendar *) nil_chk(calendar_)) setWithInt:JavaUtilCalendar_HOUR_OF_DAY withInt:hour];
      return [position getIndex];
      case JavaTextDateFormat_HOUR_OF_DAY0_FIELD:
      field = JavaUtilCalendar_HOUR_OF_DAY;
      break;
      case JavaTextDateFormat_MINUTE_FIELD:
      field = JavaUtilCalendar_MINUTE;
      break;
      case JavaTextDateFormat_SECOND_FIELD:
      field = JavaUtilCalendar_SECOND;
      break;
      case JavaTextDateFormat_MILLISECOND_FIELD:
      field = JavaUtilCalendar_MILLISECOND;
      break;
      case JavaTextSimpleDateFormat_STAND_ALONE_DAY_OF_WEEK_FIELD:
      return [self parseDayOfWeekWithNSString:string withInt:offset withBoolean:YES];
      case JavaTextDateFormat_DAY_OF_WEEK_FIELD:
      return [self parseDayOfWeekWithNSString:string withInt:offset withBoolean:NO];
      case JavaTextDateFormat_DAY_OF_YEAR_FIELD:
      field = JavaUtilCalendar_DAY_OF_YEAR;
      break;
      case JavaTextDateFormat_DAY_OF_WEEK_IN_MONTH_FIELD:
      field = JavaUtilCalendar_DAY_OF_WEEK_IN_MONTH;
      break;
      case JavaTextDateFormat_WEEK_OF_YEAR_FIELD:
      field = JavaUtilCalendar_WEEK_OF_YEAR;
      break;
      case JavaTextDateFormat_WEEK_OF_MONTH_FIELD:
      field = JavaUtilCalendar_WEEK_OF_MONTH;
      break;
      case JavaTextDateFormat_AM_PM_FIELD:
      return [self parseTextWithNSString:string withInt:offset withNSStringArray:((JavaTextDateFormatSymbols *) nil_chk(formatData_))->ampms_ withInt:JavaUtilCalendar_AM_PM];
      case JavaTextDateFormat_HOUR1_FIELD:
      position = [[[JavaTextParsePosition alloc] initWithInt:offset] autorelease];
      result = [self parseNumberWithInt:absolute withNSString:string withJavaTextParsePosition:position];
      if (result == nil) {
        return -[position getErrorIndex] - 1;
      }
      hour = [((NSNumber *) nil_chk(result)) intValue];
      if (hour == 12) {
        hour = 0;
      }
      [((JavaUtilCalendar *) nil_chk(calendar_)) setWithInt:JavaUtilCalendar_HOUR withInt:hour];
      return [position getIndex];
      case JavaTextDateFormat_HOUR0_FIELD:
      field = JavaUtilCalendar_HOUR;
      break;
      case JavaTextDateFormat_TIMEZONE_FIELD:
      return [self parseTimeZoneWithNSString:string withInt:offset];
      case JavaTextSimpleDateFormat_RFC_822_TIMEZONE_FIELD:
      return [self parseTimeZoneWithNSString:string withInt:offset];
    }
  }
  if (field != -1) {
    return [self parseNumberWithInt:absolute withNSString:string withInt:offset withInt:field withInt:0];
  }
  return offset;
}

- (int)parseDayOfWeekWithNSString:(NSString *)string
                          withInt:(int)offset
                      withBoolean:(BOOL)standAlone {
  LibcoreIcuLocaleData *ld = ((JavaTextDateFormatSymbols *) nil_chk(formatData_))->localeData_;
  int index = [self parseTextWithNSString:string withInt:offset withNSStringArray:standAlone ? ((LibcoreIcuLocaleData *) nil_chk(ld))->longStandAloneWeekdayNames_ : formatData_->weekdays_ withInt:JavaUtilCalendar_DAY_OF_WEEK];
  if (index < 0) {
    index = [self parseTextWithNSString:string withInt:offset withNSStringArray:standAlone ? ((LibcoreIcuLocaleData *) nil_chk(ld))->shortStandAloneWeekdayNames_ : formatData_->shortWeekdays_ withInt:JavaUtilCalendar_DAY_OF_WEEK];
  }
  return index;
}

- (int)parseMonthWithNSString:(NSString *)string
                      withInt:(int)offset
                      withInt:(int)count
                      withInt:(int)absolute
                  withBoolean:(BOOL)standAlone {
  if (count <= 2) {
    return [self parseNumberWithInt:absolute withNSString:string withInt:offset withInt:JavaUtilCalendar_MONTH withInt:-1];
  }
  LibcoreIcuLocaleData *ld = ((JavaTextDateFormatSymbols *) nil_chk(formatData_))->localeData_;
  int index = [self parseTextWithNSString:string withInt:offset withNSStringArray:standAlone ? ((LibcoreIcuLocaleData *) nil_chk(ld))->longStandAloneMonthNames_ : formatData_->months_ withInt:JavaUtilCalendar_MONTH];
  if (index < 0) {
    index = [self parseTextWithNSString:string withInt:offset withNSStringArray:standAlone ? ((LibcoreIcuLocaleData *) nil_chk(ld))->shortStandAloneMonthNames_ : formatData_->shortMonths_ withInt:JavaUtilCalendar_MONTH];
  }
  return index;
}

- (JavaUtilDate *)parseWithNSString:(NSString *)string
          withJavaTextParsePosition:(JavaTextParsePosition *)position {
  BOOL quote = NO;
  int next, last = -1, count = 0, offset = [((JavaTextParsePosition *) nil_chk(position)) getIndex];
  int length = [((NSString *) nil_chk(string)) length];
  [((JavaUtilCalendar *) nil_chk(calendar_)) clear];
  JavaUtilTimeZone *zone = [calendar_ getTimeZone];
  int patternLength = [((NSString *) nil_chk(pattern_)) length];
  for (int i = 0; i < patternLength; i++) {
    next = [pattern_ charAtWithInt:i];
    if (next == '\'') {
      if (count > 0) {
        if ((offset = [self parseWithNSString:string withInt:offset withChar:(unichar) last withInt:count]) < 0) {
          return [self errorWithJavaTextParsePosition:position withInt:-offset - 1 withJavaUtilTimeZone:zone];
        }
        count = 0;
      }
      if (last == next) {
        if (offset >= length || [string charAtWithInt:offset] != '\'') {
          return [self errorWithJavaTextParsePosition:position withInt:offset withJavaUtilTimeZone:zone];
        }
        offset++;
        last = -1;
      }
      else {
        last = next;
      }
      quote = !quote;
      continue;
    }
    if (!quote && (last == next || (next >= 'a' && next <= 'z') || (next >= 'A' && next <= 'Z'))) {
      if (last == next) {
        count++;
      }
      else {
        if (count > 0) {
          if ((offset = [self parseWithNSString:string withInt:offset withChar:(unichar) last withInt:-count]) < 0) {
            return [self errorWithJavaTextParsePosition:position withInt:-offset - 1 withJavaUtilTimeZone:zone];
          }
        }
        last = next;
        count = 1;
      }
    }
    else {
      if (count > 0) {
        if ((offset = [self parseWithNSString:string withInt:offset withChar:(unichar) last withInt:count]) < 0) {
          return [self errorWithJavaTextParsePosition:position withInt:-offset - 1 withJavaUtilTimeZone:zone];
        }
        count = 0;
      }
      last = -1;
      if (offset >= length || [string charAtWithInt:offset] != next) {
        return [self errorWithJavaTextParsePosition:position withInt:offset withJavaUtilTimeZone:zone];
      }
      offset++;
    }
  }
  if (count > 0) {
    if ((offset = [self parseWithNSString:string withInt:offset withChar:(unichar) last withInt:count]) < 0) {
      return [self errorWithJavaTextParsePosition:position withInt:-offset - 1 withJavaUtilTimeZone:zone];
    }
  }
  JavaUtilDate *date;
  @try {
    date = [calendar_ getTime];
  }
  @catch (JavaLangIllegalArgumentException *e) {
    return [self errorWithJavaTextParsePosition:position withInt:offset withJavaUtilTimeZone:zone];
  }
  [position setIndexWithInt:offset];
  [calendar_ setTimeZoneWithJavaUtilTimeZone:zone];
  return date;
}

- (NSNumber *)parseNumberWithInt:(int)max
                    withNSString:(NSString *)string
       withJavaTextParsePosition:(JavaTextParsePosition *)position {
  int length = [((NSString *) nil_chk(string)) length];
  int index = [((JavaTextParsePosition *) nil_chk(position)) getIndex];
  if (max > 0 && max < length - index) {
    length = index + max;
  }
  while (index < length && ([string charAtWithInt:index] == ' ' || [string charAtWithInt:index] == 0x0009)) {
    ++index;
  }
  if (max == 0) {
    [position setIndexWithInt:index];
    NSNumber *n = [((JavaTextNumberFormat *) nil_chk(numberFormat_)) parseWithNSString:string withJavaTextParsePosition:position];
    if (n != nil && [n longLongValue] < 0) {
      if ([numberFormat_ isKindOfClass:[JavaTextDecimalFormat class]]) {
        JavaTextDecimalFormat *df = (JavaTextDecimalFormat *) check_class_cast(numberFormat_, [JavaTextDecimalFormat class]);
        unichar lastChar = [string charAtWithInt:[position getIndex] - 1];
        unichar minusSign = [((JavaTextDecimalFormatSymbols *) nil_chk([df getDecimalFormatSymbols])) getMinusSign];
        if (lastChar == minusSign) {
          n = [JavaLangLong valueOfWithLong:-[n longLongValue]];
          [position setIndexWithInt:[position getIndex] - 1];
        }
      }
    }
    return n;
  }
  int result = 0;
  int digit;
  while (index < length && (digit = [JavaLangCharacter digitWithChar:[string charAtWithInt:index] withInt:10]) != -1) {
    result = result * 10 + digit;
    ++index;
  }
  if (index == [position getIndex]) {
    [position setErrorIndexWithInt:index];
    return nil;
  }
  [position setIndexWithInt:index];
  return [JavaLangInteger valueOfWithInt:result];
}

- (int)parseNumberWithInt:(int)max
             withNSString:(NSString *)string
                  withInt:(int)offset
                  withInt:(int)field
                  withInt:(int)skew {
  JavaTextParsePosition *position = [[[JavaTextParsePosition alloc] initWithInt:offset] autorelease];
  NSNumber *result = [self parseNumberWithInt:max withNSString:string withJavaTextParsePosition:position];
  if (result == nil) {
    return -[position getErrorIndex] - 1;
  }
  [((JavaUtilCalendar *) nil_chk(calendar_)) setWithInt:field withInt:[((NSNumber *) nil_chk(result)) intValue] + skew];
  return [position getIndex];
}

- (int)parseTextWithNSString:(NSString *)string
                     withInt:(int)offset
           withNSStringArray:(IOSObjectArray *)text
                     withInt:(int)field {
  int found = -1;
  for (int i = 0; i < (int) [((IOSObjectArray *) nil_chk(text)) count]; i++) {
    if ([((NSString *) nil_chk(IOSObjectArray_Get(text, i))) isEmpty]) {
      continue;
    }
    if ([((NSString *) nil_chk(string)) regionMatches:YES thisOffset:offset aString:IOSObjectArray_Get(text, i) otherOffset:0 count:[((NSString *) nil_chk(IOSObjectArray_Get(text, i))) length]]) {
      if (found == -1 || [((NSString *) nil_chk(IOSObjectArray_Get(text, i))) length] > [((NSString *) nil_chk(IOSObjectArray_Get(text, found))) length]) {
        found = i;
      }
    }
  }
  if (found != -1) {
    [((JavaUtilCalendar *) nil_chk(calendar_)) setWithInt:field withInt:found];
    return offset + [((NSString *) nil_chk(IOSObjectArray_Get(text, found))) length];
  }
  return -offset - 1;
}

- (int)parseTimeZoneWithNSString:(NSString *)string
                         withInt:(int)offset {
  BOOL foundGMT = [((NSString *) nil_chk(string)) regionMatches:offset aString:@"GMT" otherOffset:0 count:3];
  if (foundGMT) {
    offset += 3;
  }
  unichar sign;
  if (offset < [string length] && ((sign = [string charAtWithInt:offset]) == '+' || sign == '-')) {
    JavaTextParsePosition *position = [[[JavaTextParsePosition alloc] initWithInt:offset + 1] autorelease];
    NSNumber *result = [((JavaTextNumberFormat *) nil_chk(numberFormat_)) parseWithNSString:string withJavaTextParsePosition:position];
    if (result == nil) {
      return -[position getErrorIndex] - 1;
    }
    int hour = [((NSNumber *) nil_chk(result)) intValue];
    int raw = hour * 3600000;
    int index = [position getIndex];
    if (index < [string length] && [string charAtWithInt:index] == ':') {
      [position setIndexWithInt:index + 1];
      result = [numberFormat_ parseWithNSString:string withJavaTextParsePosition:position];
      if (result == nil) {
        return -[position getErrorIndex] - 1;
      }
      int minute = [((NSNumber *) nil_chk(result)) intValue];
      raw += minute * 60000;
    }
    else if (hour >= 24) {
      raw = (hour / 100 * 3600000) + (hour % 100 * 60000);
    }
    if (sign == '-') {
      raw = -raw;
    }
    [((JavaUtilCalendar *) nil_chk(calendar_)) setTimeZoneWithJavaUtilTimeZone:[[[JavaUtilSimpleTimeZone alloc] initWithInt:raw withNSString:@""] autorelease]];
    return [position getIndex];
  }
  if (foundGMT) {
    [((JavaUtilCalendar *) nil_chk(calendar_)) setTimeZoneWithJavaUtilTimeZone:[JavaUtilTimeZone getTimeZoneWithNSString:@"GMT"]];
    return offset;
  }
  {
    IOSObjectArray *a__ = [((JavaTextDateFormatSymbols *) nil_chk(formatData_)) internalZoneStrings];
    id const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    id const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      IOSObjectArray *row = (*b__++);
      for (int i = LibcoreIcuTimeZoneNames_LONG_NAME; i < LibcoreIcuTimeZoneNames_NAME_COUNT; ++i) {
        if (IOSObjectArray_Get(nil_chk(row), i) == nil) {
          continue;
        }
        if ([string regionMatches:YES thisOffset:offset aString:IOSObjectArray_Get(row, i) otherOffset:0 count:[((NSString *) nil_chk(IOSObjectArray_Get(row, i))) length]]) {
          JavaUtilTimeZone *zone = [JavaUtilTimeZone getTimeZoneWithNSString:IOSObjectArray_Get(row, LibcoreIcuTimeZoneNames_OLSON_NAME)];
          if (zone == nil) {
            return -offset - 1;
          }
          int raw = [((JavaUtilTimeZone *) nil_chk(zone)) getRawOffset];
          if (i == LibcoreIcuTimeZoneNames_LONG_NAME_DST || i == LibcoreIcuTimeZoneNames_SHORT_NAME_DST) {
            int dstSavings = [zone getDSTSavings];
            if (dstSavings == 0) {
              dstSavings = 3600000;
            }
            raw += dstSavings;
          }
          [((JavaUtilCalendar *) nil_chk(calendar_)) setTimeZoneWithJavaUtilTimeZone:[[[JavaUtilSimpleTimeZone alloc] initWithInt:raw withNSString:@""] autorelease]];
          return offset + [((NSString *) nil_chk(IOSObjectArray_Get(row, i))) length];
        }
      }
    }
  }
  return -offset - 1;
}

- (void)set2DigitYearStartWithJavaUtilDate:(JavaUtilDate *)date {
  JavaTextSimpleDateFormat_set_defaultCenturyStart_(self, (JavaUtilDate *) check_class_cast([((JavaUtilDate *) nil_chk(date)) clone], [JavaUtilDate class]));
  JavaUtilCalendar *cal = [[[JavaUtilGregorianCalendar alloc] init] autorelease];
  [cal setTimeWithJavaUtilDate:defaultCenturyStart_];
  creationYear_ = [cal getWithInt:JavaUtilCalendar_YEAR];
}

- (void)setDateFormatSymbolsWithJavaTextDateFormatSymbols:(JavaTextDateFormatSymbols *)value {
  JavaTextSimpleDateFormat_set_formatData_(self, (JavaTextDateFormatSymbols *) check_class_cast([((JavaTextDateFormatSymbols *) nil_chk(value)) clone], [JavaTextDateFormatSymbols class]));
}

- (NSString *)toLocalizedPattern {
  return [JavaTextSimpleDateFormat convertPatternWithNSString:pattern_ withNSString:JavaTextSimpleDateFormat_PATTERN_CHARS_ withNSString:[((JavaTextDateFormatSymbols *) nil_chk(formatData_)) getLocalPatternChars] withBoolean:NO];
}

+ (NSString *)convertPatternWithNSString:(NSString *)template_
                            withNSString:(NSString *)fromChars
                            withNSString:(NSString *)toChars
                             withBoolean:(BOOL)check {
  if (!check && [((NSString *) nil_chk(fromChars)) isEqual:toChars]) {
    return template_;
  }
  BOOL quote = NO;
  JavaLangStringBuilder *output = [[[JavaLangStringBuilder alloc] init] autorelease];
  int length = [((NSString *) nil_chk(template_)) length];
  for (int i = 0; i < length; i++) {
    int index;
    unichar next = [template_ charAtWithInt:i];
    if (next == '\'') {
      quote = !quote;
    }
    if (!quote && (index = [((NSString *) nil_chk(fromChars)) indexOf:next]) != -1) {
      [output appendWithChar:[((NSString *) nil_chk(toChars)) charAtWithInt:index]];
    }
    else if (check && !quote && ((next >= 'a' && next <= 'z') || (next >= 'A' && next <= 'Z'))) {
      @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"Invalid pattern character '%C' in '%@'", next, template_]] autorelease];
    }
    else {
      [output appendWithChar:next];
    }
  }
  if (quote) {
    @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Unterminated quote"] autorelease];
  }
  return [output description];
}

- (NSString *)toPattern {
  return pattern_;
}

- (void)dealloc {
  JreMemDebugRemove(self);
  JavaTextSimpleDateFormat_set_defaultCenturyStart_(self, nil);
  JavaTextSimpleDateFormat_set_formatData_(self, nil);
  JavaTextSimpleDateFormat_set_pattern_(self, nil);
  [super dealloc];
}

- (void)copyAllFieldsTo:(JavaTextSimpleDateFormat *)other {
  [super copyAllFieldsTo:other];
  other->creationYear_ = creationYear_;
  JavaTextSimpleDateFormat_set_defaultCenturyStart_(other, defaultCenturyStart_);
  JavaTextSimpleDateFormat_set_formatData_(other, formatData_);
  JavaTextSimpleDateFormat_set_pattern_(other, pattern_);
}

- (NSArray *)memDebugStrongReferences {
  NSMutableArray *result =
      [[[super memDebugStrongReferences] mutableCopy] autorelease];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:pattern_ name:@"pattern"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:formatData_ name:@"formatData"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:defaultCenturyStart_ name:@"defaultCenturyStart"]];
  return result;
}

@end
