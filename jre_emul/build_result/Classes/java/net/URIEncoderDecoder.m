//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//
//  Created by Larry Tin <dev@goodow.com>
//

#include "IOSByteArray.h"
#include "IOSCharArray.h"
#include "IOSClass.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/UnsupportedEncodingException.h"
#include "java/lang/Character.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/StringBuilder.h"
#include "java/net/URIEncoderDecoder.h"
#include "java/net/URISyntaxException.h"

@implementation JavaNetURIEncoderDecoder

+ (NSArray *)memDebugStaticReferences {
  NSMutableArray *result = [NSMutableArray array];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaNetURIEncoderDecoder_digits_ name:@"JavaNetURIEncoderDecoder_digits_"]];
  [result addObject:[JreMemDebugStrongReference strongReferenceWithObject:JavaNetURIEncoderDecoder_encoding_ name:@"JavaNetURIEncoderDecoder_encoding_"]];
  return result;
}

static NSString * JavaNetURIEncoderDecoder_digits_ = @"0123456789ABCDEF";
static NSString * JavaNetURIEncoderDecoder_encoding_ = @"UTF8";

+ (NSString *)digits {
  return JavaNetURIEncoderDecoder_digits_;
}

+ (NSString *)encoding {
  return JavaNetURIEncoderDecoder_encoding_;
}

+ (void)validateWithNSString:(NSString *)s
                withNSString:(NSString *)legal {
  for (int i = 0; i < [((NSString *) nil_chk(s)) length]; ) {
    unichar ch = [s charAtWithInt:i];
    if (ch == '%') {
      do {
        if (i + 2 >= [s length]) {
          @throw [[[JavaNetURISyntaxException alloc] initWithNSString:s withNSString:@"Incomplete % sequence" withInt:i] autorelease];
        }
        int d1 = [JavaLangCharacter digitWithChar:[s charAtWithInt:i + 1] withInt:16];
        int d2 = [JavaLangCharacter digitWithChar:[s charAtWithInt:i + 2] withInt:16];
        if (d1 == -1 || d2 == -1) {
          @throw [[[JavaNetURISyntaxException alloc] initWithNSString:s withNSString:[NSString stringWithFormat:@"Invalid %% sequence (%@)", [s substring:i endIndex:i + 3]] withInt:i] autorelease];
        }
        i += 3;
      }
      while (i < [s length] && [s charAtWithInt:i] == '%');
      continue;
    }
    if (!((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || [((NSString *) nil_chk(legal)) indexOf:ch] > -1 || (ch > 127 && ![JavaLangCharacter isSpaceCharWithChar:ch] && ![JavaLangCharacter isISOControlWithChar:ch]))) {
      @throw [[[JavaNetURISyntaxException alloc] initWithNSString:s withNSString:@"Illegal character" withInt:i] autorelease];
    }
    i++;
  }
}

+ (IOSObjectArray *)__exceptions_validateWithNSString_withNSString_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaNetURISyntaxException getClass] } count:1 type:[IOSClass getClass]];
}

+ (void)validateSimpleWithNSString:(NSString *)s
                      withNSString:(NSString *)legal {
  for (int i = 0; i < [((NSString *) nil_chk(s)) length]; ) {
    unichar ch = [s charAtWithInt:i];
    if (!((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || [((NSString *) nil_chk(legal)) indexOf:ch] > -1)) {
      @throw [[[JavaNetURISyntaxException alloc] initWithNSString:s withNSString:@"Illegal character" withInt:i] autorelease];
    }
    i++;
  }
}

+ (IOSObjectArray *)__exceptions_validateSimpleWithNSString_withNSString_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaNetURISyntaxException getClass] } count:1 type:[IOSClass getClass]];
}

+ (NSString *)quoteIllegalWithNSString:(NSString *)s
                          withNSString:(NSString *)legal {
  JavaLangStringBuilder *buf = [[[JavaLangStringBuilder alloc] init] autorelease];
  for (int i = 0; i < [((NSString *) nil_chk(s)) length]; i++) {
    unichar ch = [s charAtWithInt:i];
    if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || [((NSString *) nil_chk(legal)) indexOf:ch] > -1 || (ch > 127 && ![JavaLangCharacter isSpaceCharWithChar:ch] && ![JavaLangCharacter isISOControlWithChar:ch])) {
      [buf appendWithChar:ch];
    }
    else {
      IOSByteArray *bytes = [[NSString stringWithCharacters:[IOSCharArray arrayWithCharacters:(unichar[]){ ch } count:1]] getBytesWithCharsetName:JavaNetURIEncoderDecoder_encoding_];
      for (int j = 0; j < (int) [((IOSByteArray *) nil_chk(bytes)) count]; j++) {
        [buf appendWithChar:'%'];
        [buf appendWithChar:[((NSString *) nil_chk(JavaNetURIEncoderDecoder_digits_)) charAtWithInt:(IOSByteArray_Get(bytes, j) & (int) 0xf0) >> 4]];
        [buf appendWithChar:[JavaNetURIEncoderDecoder_digits_ charAtWithInt:IOSByteArray_Get(bytes, j) & (int) 0xf]];
      }
    }
  }
  return [buf description];
}

+ (IOSObjectArray *)__exceptions_quoteIllegalWithNSString_withNSString_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoUnsupportedEncodingException getClass] } count:1 type:[IOSClass getClass]];
}

+ (NSString *)encodeOthersWithNSString:(NSString *)s {
  JavaLangStringBuilder *buf = [[[JavaLangStringBuilder alloc] init] autorelease];
  for (int i = 0; i < [((NSString *) nil_chk(s)) length]; i++) {
    unichar ch = [s charAtWithInt:i];
    if (ch <= 127) {
      [buf appendWithChar:ch];
    }
    else {
      IOSByteArray *bytes = [[NSString stringWithCharacters:[IOSCharArray arrayWithCharacters:(unichar[]){ ch } count:1]] getBytesWithCharsetName:JavaNetURIEncoderDecoder_encoding_];
      for (int j = 0; j < (int) [((IOSByteArray *) nil_chk(bytes)) count]; j++) {
        [buf appendWithChar:'%'];
        [buf appendWithChar:[((NSString *) nil_chk(JavaNetURIEncoderDecoder_digits_)) charAtWithInt:(IOSByteArray_Get(bytes, j) & (int) 0xf0) >> 4]];
        [buf appendWithChar:[JavaNetURIEncoderDecoder_digits_ charAtWithInt:IOSByteArray_Get(bytes, j) & (int) 0xf]];
      }
    }
  }
  return [buf description];
}

+ (IOSObjectArray *)__exceptions_encodeOthersWithNSString_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoUnsupportedEncodingException getClass] } count:1 type:[IOSClass getClass]];
}

+ (NSString *)decodeWithNSString:(NSString *)s {
  JavaLangStringBuilder *result = [[[JavaLangStringBuilder alloc] init] autorelease];
  JavaIoByteArrayOutputStream *out = [[[JavaIoByteArrayOutputStream alloc] init] autorelease];
  for (int i = 0; i < [((NSString *) nil_chk(s)) length]; ) {
    unichar c = [s charAtWithInt:i];
    if (c == '%') {
      [out reset];
      do {
        if (i + 2 >= [s length]) {
          @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"Incomplete %% sequence at: %d", i]] autorelease];
        }
        int d1 = [JavaLangCharacter digitWithChar:[s charAtWithInt:i + 1] withInt:16];
        int d2 = [JavaLangCharacter digitWithChar:[s charAtWithInt:i + 2] withInt:16];
        if (d1 == -1 || d2 == -1) {
          @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"Invalid %% sequence (%@) at: %@", [s substring:i endIndex:i + 3], [NSString valueOfInt:i]]] autorelease];
        }
        [out writeWithInt:(char) ((d1 << 4) + d2)];
        i += 3;
      }
      while (i < [s length] && [s charAtWithInt:i] == '%');
      [result appendWithNSString:[out toStringWithNSString:JavaNetURIEncoderDecoder_encoding_]];
      continue;
    }
    [result appendWithChar:c];
    i++;
  }
  return [result description];
}

+ (IOSObjectArray *)__exceptions_decodeWithNSString_ {
  return [IOSObjectArray arrayWithObjects:(id[]) { [JavaIoUnsupportedEncodingException getClass] } count:1 type:[IOSClass getClass]];
}

- (id)init {
  return JreMemDebugAdd([super init]);
}

@end
